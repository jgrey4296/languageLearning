* CSharp Notes
** Building
   mcs for compiling,
   mono for running the compiled executable
   xbuild on linux instead of msbuild, using .sln and .csproj files
   xbuild /t:Target
   xbuild /p:Configuration=Release
** Unity
   Typical base class: Monobehaviour
   using UnityEngine;
*** Editor stuff
    Example class to edit:
    #+begin_src csharp
      using System.Collections;
      using System.Collections.Generic;
      using UnityEngine;

      public class JGBezier : MonoBehaviour {
    	  private static class Bezier {
    		  public static Vector3 GetPoint (Vector3 p0, Vector3 p1, Vector3 p2, float t){
    			  //Vector3 firstLerp = Vector3.Lerp (p0, p1, t);
    			  //Vector3 secondLerp = Vector3.Lerp (p1, p2, t);
    			  //return Vector3.Lerp (firstLerp, secondLerp, t);
    			  t = Mathf.Clamp01(t);
    			  float oneMinusT = 1f - t;
    			  return oneMinusT * oneMinusT * p0 +
    			  2f * oneMinusT * t * p1 +
    			  t * t * p2;

    		  }

    		  public static Vector3 GetFirstDerivative (Vector3 p0, Vector3 p1, Vector3 p2, float t){
    			  return 2f * (1f - t) * (p1 - p0) +
    			  2f * t * (p2 - p1);
    		  }
    	  }

    	  public Vector3[] points;

    	  public void Reset () {
    		  points = new Vector3[] {
    			  new Vector3 (1f, 0f, 0f),
    			  new Vector3 (2f, 0f, 0f),
    			  new Vector3 (3f, 0f, 0f)
    		  };
    	  }

    	  public Vector3 GetPoint (float t) {
    		  return transform.TransformPoint (Bezier.GetPoint (points [0], points [1], points [2], t));
    	  }

    	  public Vector3 GetVelocity( float t){
    		  return transform.TransformPoint(Bezier.GetFirstDerivative(points[0], points[1], points[2], t)) - 
    			  transform.position;
    	  }
      }
    #+end_src
    Code for the editor:
    #+begin_src csharp
      using System.Collections;
      using System.Collections.Generic;
      using UnityEngine;
      using UnityEditor;

      [CustomEditor(typeof(JGBezier))]
      public class BezierInspector : Editor {

    	  private JGBezier curve;
    	  private Transform cTransform;
    	  private Quaternion cRotation;
    	  private const int lineSteps = 10;

    	  private void OnSceneGUI () {
    		  curve = target as JGBezier;
    		  cTransform = curve.transform;
    		  cRotation = Tools.pivotRotation == PivotRotation.Local ? cTransform.rotation : Quaternion.identity;

    		  Vector3 p0 = ShowPoint (0);
    		  Vector3 p1 = ShowPoint (1);
    		  Vector3 p2 = ShowPoint (2);

    		  Handles.color = Color.grey;
    		  Handles.DrawLine (p0, p1);
    		  Handles.DrawLine (p1, p2);

    		  Handles.color = Color.green;
    		  Vector3 lineStart = curve.GetPoint (0f);
    		  Handles.DrawLine (lineStart, lineStart + curve.GetVelocity (0f));
    		  for (int i = 1; i <= lineSteps; i++) {
    			  Handles.color = Color.red;
    			  Vector3 lineEnd = curve.GetPoint (i / (float)lineSteps);
    			  Handles.DrawLine (lineStart, lineEnd);
    			  Handles.color = Color.green;
    			  Handles.DrawLine (lineEnd, lineEnd + curve.GetVelocity (i / (float)lineSteps));
    			  lineStart = lineEnd;
    		  }

    	  }

    	  private Vector3 ShowPoint (int index){
    		  Vector3 point = cTransform.TransformPoint (curve.points [index]);
    		  EditorGUI.BeginChangeCheck ();
    		  point = Handles.DoPositionHandle (point, cRotation);
    		  if (EditorGUI.EndChangeCheck ()) {
    			  Undo.RecordObject (curve, "Move Point");
    			  EditorUtility.SetDirty (curve);
    			  curve.points [index] = cTransform.InverseTransformPoint (point);
    		  }
    		  return point;
    	  }
      }
    #+end_src
*** Splines
    Base Spline class:
    #+begin_src csharp
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;

      public class JGSpline : MonoBehaviour {
    	  private static class Bezier {
    		  public static Vector3 GetPoint3 (Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, float t){
    			  t = Mathf.Clamp01 (t);
    			  float oneMinusT = 1f - t;
    			  return oneMinusT * oneMinusT * oneMinusT * p0 +
    			  3f * oneMinusT * oneMinusT * t * p1 +
    			  3f * oneMinusT * t * t * p2 +
    			  t * t * t * p3;
    		  }

    		  public static Vector3 GetFirstDerivative3 (Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, float t){
    			  t = Mathf.Clamp01 (t);
    			  float oneMinusT = 1f - t;
    			  return 3f * oneMinusT * oneMinusT * (p1 - p0) +
    			  6f * oneMinusT * t * (p2 - p1) +
    			  3f * t * t * (p3 - p2);
    		  }

    	  }


    	  public Vector3[] points;

    	  public void Reset () {
    		  points = new Vector3[] {
    			  new Vector3 (1f, 0f, 0f),
    			  new Vector3 (2f, 0f, 0f),
    			  new Vector3 (3f, 0f, 0f),
    			  new Vector3 (4f, 0f, 0f)
    		  };
    	  }

    	  public Vector3 GetPoint (float t) {
    		  int i;
    		  if (t >= 1f) {
    			  t = 1f;
    			  i = points.Length - 4;
    		  } else {
    			  t = Mathf.Clamp01 (t) * CurveCount;
    			  i = (int)t;
    			  t -= i;
    			  i *= 3;
    		  }
    		  return transform.TransformPoint (Bezier.GetPoint3 (points [i], points [i+1], points [i+2], points[3], t));
    	  }

    	  public Vector3 GetVelocity( float t){
    		  int i;
    		  if (t >= 1f) {
    			  t = 1f;
    			  i = points.Length - 4;
    		  } else {
    			  t = Mathf.Clamp01 (t) * CurveCount;
    			  i = (int)t;
    			  t -= i;
    			  i *= 3;
    		  }
    		  return transform.TransformPoint(Bezier.GetFirstDerivative3(points[0], points[1], points[2], points[3], t)) - 
    			  transform.position;
    	  }

    	  public Vector3 GetDirection (float t){
    		  return GetVelocity (t).normalized * 2;
    	  }

    	  public void AddCurve(){
    		  Vector3 point = points [points.Length - 1];
    		  System.Array.Resize (ref points, points.Length + 3);
    		  point.x += 1f;
    		  points [points.Length - 3] = point;
    		  point.x += 1f;
    		  points [points.Length - 2] = point;
    		  point.x += 1f;
    		  points [points.Length - 1] = point;
    	  }

    	  public int CurveCount {
    		  get {
    			  return (points.Length - 1) / 3;
    		  }
    	  }

      }
    #+end_src

    Inspector:
    #+begin_src csharp
      using System.Collections;
      using System.Collections.Generic;
      using UnityEngine;
      using UnityEditor;

      [CustomEditor(typeof(JGSpline))]
      public class SplineInspector : Editor {

    	  private JGSpline curve;
    	  private Transform cTransform;
    	  private Quaternion cRotation;
    	  private const int lineSteps = 10;
    	  private const float directionScale = 0.5f;
    	  private const int stepsPerCurve = 10;
    	  private const float handleSize = 0.04f;
    	  private const float pickSize = 0.06f;
    	  private int selectedIndex = -1;

    	  public override void OnInspectorGUI (){
    		  DrawDefaultInspector ();
    		  curve = target as JGSpline;
    		  if (GUILayout.Button ("Add Curve")) {
    			  Undo.RecordObject (curve, "Add Curve");
    			  curve.AddCurve ();
    			  EditorUtility.SetDirty (curve);
    		  }
    	  }

    	  private void OnSceneGUI () {
    		  curve = target as JGSpline;
    		  cTransform = curve.transform;
    		  cRotation = Tools.pivotRotation == PivotRotation.Local ? cTransform.rotation : Quaternion.identity;

    		  //Loop 
    		  Vector3 p0 = ShowPoint (0);
    		  for (int i = 1; i < curve.points.Length; i += 3) {
    			  Vector3 p1 = ShowPoint (i);
    			  Vector3 p2 = ShowPoint (i + 1);
    			  Vector3 p3 = ShowPoint (i + 2);

    			  Handles.color = Color.grey;
    			  Handles.DrawLine (p0, p1);
    			  Handles.DrawLine (p2, p3);
			
    			  Handles.DrawBezier (p0, p3, p1, p2, Color.white, null, 2f);
    			  p0 = p3;
    		  }

    		  ShowDirections ();
    		  /* not needed because of Handles.DrawBezier
    		  Handles.color = Color.green;
    		  Vector3 lineStart = curve.GetPoint (0f);
    		  Handles.DrawLine (lineStart, lineStart + curve.GetDirection (0f));
    		  for (int i = 1; i <= lineSteps; i++) {
    			  Handles.color = Color.red;
    			  Vector3 lineEnd = curve.GetPoint (i / (float)lineSteps);
    			  Handles.DrawLine (lineStart, lineEnd);
    			  Handles.color = Color.green;
    			  Handles.DrawLine (lineEnd, lineEnd + curve.GetDirection (i / (float)lineSteps));
    			  lineStart = lineEnd;
    		  }
    		  ,*/

    	  }

    	  //get s a value while registering for changes
    	  private Vector3 ShowPoint (int index){
    		  Vector3 point = cTransform.TransformPoint (curve.points [index]);
    		  float size = HandleUtility.GetHandleSize (point);
    		  Handles.color = Color.white;
    		  if (Handles.Button (point, cRotation, size * handleSize, size * pickSize, Handles.DotHandleCap)) {
    			  selectedIndex = index;
    		  }
    		  if (selectedIndex == index) {
    			  EditorGUI.BeginChangeCheck ();
    			  point = Handles.DoPositionHandle (point, cRotation);
    			  if (EditorGUI.EndChangeCheck ()) {
    				  Undo.RecordObject (curve, "Move Point");
    				  EditorUtility.SetDirty (curve);
    				  curve.points [index] = cTransform.InverseTransformPoint (point);
    			  }
    		  }
    		  return point;
    	  }

    	  private void ShowDirections(){
    		  Handles.color = Color.green;
    		  Vector3 point = curve.GetPoint (0f);
    		  Handles.DrawLine (point, point + curve.GetDirection (0f) * directionScale);
    		  int steps = stepsPerCurve * curve.CurveCount;
    		  for (int i = 1; i <= steps; i++) {
    			  point = curve.GetPoint(i / (float)steps);
    			  Handles.DrawLine(point, point + curve.GetDirection( i / (float) steps) * directionScale);
    		  }
    	  }


      }

    #+end_src


** Lambdas
   Func<int, int, bool> a = (x,y) => x == y;
** Sorting
   List<Order> SortedList = objListOrder.OrderBy(o => o.OrderDate).ToList();

   Alt:
   var x = from x in list orderBy x.val select x
