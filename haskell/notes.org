* Haskell Notes
Real World Haskell

** CLI programs
   1) ghc    -   compiles programs
   2) runghc -   allows running of hs programs without compiling
   3) ghci   -   REPL interpreter
   3) cabal  -   package manager
** useful command line options:
-Wall
-Werror
-Wwarn
-fwarn-name-shadowing
--supported-languages
--supported-extensions
--show-packages

*** ghci commands
:module + Data.Ratio
:info x
:set +t --->  makes ghci print type information automatically

   :browse[!] [[*]<mod>]       display the names defined by module <mod>
   (!: more details; *: all top-level names)
   :help, :?                   display this list of commands
   :info[!] [<name> ...]       display information about the given names
   (!: do not filter instances)
   :kind[!] <type>             show the kind of <type>
   :module [+/-] [*]<mod> ...  set the context for expression evaluation
   
   :show bindings              show the current bindings made at the prompt
   :show breaks                show the active breakpoints
   :show context               show the breakpoint context
   :show imports               show the current imports
   :show linker                show current linker state
   :show modules               show the currently loaded modules
   :show packages              show the currently active package flags
   :show paths                 show the currently active search paths
   :show language              show the currently active language flags
   :show <setting>             show value of <setting>, which is one of
   [args, prog, prompt, editor, stop]
   :showi language             show language flags for interactive evaluation
   
** language


*** Pragmas
{-# LANGUAGE TypeSynonymInstances, OverlappingInstances, FlexibleInstances, GeneralizedNewtypeDeriving #-}
type synonyms allows useful for typeclass instances for Strings (as strings are [Char],
which are [a] )
overlapping instances allows for the most specific instance functions of typeclasses 
FlexibleInstances goes beyond haskell98 typechecking, allowing eg: Functors on Either Int b
gen newtype deriving to allow derivations of Monads

possible *MultiParamTypeClasses*

*** Monads
    >>= , >>, return
    do notation: do { x <- func; return $ x + 2 }

    data that are instances of Monad are typically instances of Functor. 
    So instances need to implement >>, >>=, return, fail?, and fmap

*** STATE MONAD
import Control.Monad.State
--Construct an initial state constructor:
let initialState = state $ \x -> (0,x)

-- create a modifying function of the state:
let stateMod oldValue = state $ \oldState-> (oldValue+1,oldState-1)
let stateMod2 oldValue = state $ \oldState -> (oldValue-1,oldState+1)

-- or do syntax:
let stateMod3 = \val -> do { state <- get; put (state-1); return (val+1) }

--run a sequence of actions on the state, starting with an initial value:
let result = runState (initialState >>= stateMod >>= stateMod) 10

--can also do: (for lists/strings)
let strMod v = do { st <- get; let (h:tl) = st in do put tl; return h; }

the value is passed in explicitly, while the state container is passed
implicitly, to be modified with 'get' and 'put'


-- State >>= 
theMonad >>=  theFunction = \s -> (theFunction value) s'
								 where (value,s') = theMonad s


*** Association Lists and maps
let a = [(1,"blah"),(2,"bloo"),(3,"blee")]
lookup 2 a

import qualified Data.Map as Map
let aMap = Map.fromList a

let aMap' = Map.insert 10 "awef" aMap

*** List comprehensions
comp xs ys = [(x,y) | x <- xs, y <- ys]
with guards or lets:
let abs xs ys = [(x,y) | (x,y) <- zip xs ys, x+y < 60, x+y > 20]
*** Record Syntax 
can copy and modify a record datatype:
data Test = Test { theInt :: Int, theString :: String }
chng x y = x { theInt = y }

see state monad for use case

*** Precedence and Associativity (fixity)
1 = lowest, 9 = highest
specify fixity type and priority thus:
(+) :: a -> a -> a
infixl 5 +
or 
infixr 5 +
*** Regex
import Text.Regex.Posix
use =~, polymorphic so specify return type:
"my test" =~ "test" :: Bool --match exists or not
"my test" =~ "t.*" :: String --matching string

"blah bloo blee" =~ "(bl)" :: [ [String] ] --all matches
--or use getAllTextMatches() :: [String]

use :: (String, String, String) to get prior,matching,post text

TODO: find a regex library that has meta characters

*** FilePaths
import System.FilePath
concat filepaths using </>

*** qualified imports 
import qualified Data.ByteString.Lazy as L

import Mod -- imports everything, qualified and unqualified
import Mod () -- imports nothing
import Mod (x,y) -- imports only x and y, unqualified
import qualified Mod -- import everything qualified Mod.x...
import qualified Mod (x,y) -- qual only x and y
import Mod as Foo --everything unqual and as Foo.x..
import Mod as Foo (x,y) -- x,y, Foo.x Foo.y
import qualified Mod as Foo (x,y) -- only Foo.x Foo.y




*** type and newtype and data
data     : creation of new types.
type     : synonyms of types *that are interchangeable*
newtype  : *constrained* synonym of type *that is not interchangeable*

newtype constructors take a single parameter, are typically a wrapping record to give an auto unwrap

*** general notes
[1..5] = [1,2,3,4,5] ;;beware roundoff errors
map (\x -> x + 2) [1,2,3,4]
map (\x -> x > 2) [1,2,3,4]
foldr
foldl' --prefer foldl' to foldl due to thunk space issues

*** Modules
module *name* 
(
   exportedValues
   , ExportedType(...) --adds constructors
) where
*definitions*

*** Typeclasses:
definition:
class BasicEq a where
	isEqual :: a -> a -> Bool
    isEqual x y = not (isNotEqual x y)

    isNotEqual :: a -> a -> Bool
    isNotEqual x y = not (isEqual x y)


instantiation:
instance BasicEq Bool where
	isEqual True  True  = True
    isEqual False False = True
    isEqual _     _     = False

instance (Typeclass) (DataType) where
	(functions)

**** Automatic derivation:
can occur for Read, Show, Bounded, Enum, Eq, Ord

*** Simple Lambda pattern matching:
data Test = Something Int Int
let a = Test 5 3
let myFunc = \x -> case x of Something a b -> a + b

** Parsec Notes
   parsers as variables requires the flag -XFlexibleContexts
   use Text.Parsec, Text.Parsec.String, Text.Parsec.Char
   Text.Parsec.Char and Text.Parsec.String simplify types   

   General Parse Call:
   parse $PARSER "$ERROR" "$INPUT"
   
   Satisfy performs tests of chars to accept
   satisfy :: (Char -> Bool) -> Parser Char
   
   Standard Parsers:
   anyChar, space, newline, tab,
   upper, lower, alphaNum, letter, digit, hexDigit, octDigit
   string

   oneOf, noneOf, many, skipMany
   
   to convert to numbers:
   read "1234" :: Integer 

   to ignore a parse:
   void $ parser  

   ignore the second parser:
   x <- p <* whitespace

   Options (to backtrack, wrap with 'try' )
   p <|> p2

   Apply a function to a parse result:
   ctor <$> p

   Write new parsers, use type declaration to hint:
#+begin_src haskell
  var :: Parser (Char, String)
  var = do
    fc <- firstChar
    rest <- many nonFirstChar
    return (fc, rest)
    where
      firstChar = satisfy ( \a -> isLetter a || a == '_' )
      nonFirstChar = satisfy ( \a -> isDigit a || isLetter a || a == '_' )
#+end_src



