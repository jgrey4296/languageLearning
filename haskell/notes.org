* Haskell Notes
Real World Haskell

** CLI programs
   1) ghc    -   compiles programs
   2) runghc -   allows running of hs programs without compiling
   3) ghci   -   REPL interpreter
   3) cabal  -   package manager
** useful command line options:
-Wall
-Werror
-Wwarn
-fwarn-name-shadowing
--supported-languages
--supported-extensions
--show-packages

*** ghci commands
:module + Data.Ratio
:info x
:set +t --->  makes ghci print type information automatically

   :browse[!] [[*]<mod>]       display the names defined by module <mod>
   (!: more details; *: all top-level names)
   :help, :?                   display this list of commands
   :info[!] [<name> ...]       display information about the given names
   (!: do not filter instances)
   :kind[!] <type>             show the kind of <type>
   :module [+/-] [*]<mod> ...  set the context for expression evaluation
   
   :show bindings              show the current bindings made at the prompt
   :show breaks                show the active breakpoints
   :show context               show the breakpoint context
   :show imports               show the current imports
   :show linker                show current linker state
   :show modules               show the currently loaded modules
   :show packages              show the currently active package flags
   :show paths                 show the currently active search paths
   :show language              show the currently active language flags
   :show <setting>             show value of <setting>, which is one of
   [args, prog, prompt, editor, stop]
   :showi language             show language flags for interactive evaluation
   
** language
*** Pragmas
{-# LANGUAGE TypeSynonymInstances, OverlappingInstances, FlexibleInstances, GeneralizedNewtypeDeriving #-}
type synonyms allows useful for typeclass instances for Strings (as strings are [Char],
which are [a] )
overlapping instances allows for the most specific instance functions of typeclasses 
FlexibleInstances goes beyond haskell98 typechecking, allowing eg: Functors on Either Int b
gen newtype deriving to allow derivations of Monads

possible *MultiParamTypeClasses*

*** Monads
    >>= , >>, return
    do notation: do { x <- func; return $ x + 2 }

    data that are instances of Monad are typically instances of Functor. 
    So instances need to implement >>, >>=, return, fail?, and fmap

*** STATE MONAD
import Control.Monad.State
--Construct an initial state constructor:
let initialState = state $ \x -> (0,x)

-- create a modifying function of the state:
let stateMod oldValue = state $ \oldState-> (oldValue+1,oldState-1)
let stateMod2 oldValue = state $ \oldState -> (oldValue-1,oldState+1)

-- or do syntax:
let stateMod3 = \val -> do { state <- get; put (state-1); return (val+1) }

--run a sequence of actions on the state, starting with an initial value:
let result = runState (initialState >>= stateMod >>= stateMod) 10

--can also do: (for lists/strings)
let strMod v = do { st <- get; let (h:tl) = st in do put tl; return h; }

the value is passed in explicitly, while the state container is passed
implicitly, to be modified with 'get' and 'put'


-- State >>= 
theMonad >>=  theFunction = \s -> (theFunction value) s'
								 where (value,s') = theMonad s

*** Association Lists and maps
let a = [(1,"blah"),(2,"bloo"),(3,"blee")]
lookup 2 a

import qualified Data.Map as Map
let aMap = Map.fromList a

let aMap' = Map.insert 10 "awef" aMap

*** List comprehensions
comp xs ys = [(x,y) | x <- xs, y <- ys]
with guards or lets:
let abs xs ys = [(x,y) | (x,y) <- zip xs ys, x+y < 60, x+y > 20]
*** Record Syntax 
can copy and modify a record datatype:
data Test = Test { theInt :: Int, theString :: String }
chng x y = x { theInt = y }

see state monad for use case

*** Precedence and Associativity (fixity)
1 = lowest, 9 = highest
specify fixity type and priority thus:
(+) :: a -> a -> a
infixl 5 +
or 
infixr 5 +
*** Regex
import Text.Regex.Posix
use =~, polymorphic so specify return type:
"my test" =~ "test" :: Bool --match exists or not
"my test" =~ "t.*" :: String --matching string

"blah bloo blee" =~ "(bl)" :: [ [String] ] --all matches
--or use getAllTextMatches() :: [String]

use :: (String, String, String) to get prior,matching,post text

TODO: find a regex library that has meta characters

*** FilePaths
import System.FilePath
concat filepaths using </>

*** qualified imports 
import qualified Data.ByteString.Lazy as L

import Mod -- imports everything, qualified and unqualified
import Mod () -- imports nothing
import Mod (x,y) -- imports only x and y, unqualified
import qualified Mod -- import everything qualified Mod.x...
import qualified Mod (x,y) -- qual only x and y
import Mod as Foo --everything unqual and as Foo.x..
import Mod as Foo (x,y) -- x,y, Foo.x Foo.y
import qualified Mod as Foo (x,y) -- only Foo.x Foo.y




*** type and newtype and data
data     : creation of new types.
type     : synonyms of types *that are interchangeable*
newtype  : *constrained* synonym of type *that is not interchangeable*

newtype constructors take a single parameter, are typically a wrapping record to give an auto unwrap

*** general notes
[1..5] = [1,2,3,4,5] ;;beware roundoff errors
map (\x -> x + 2) [1,2,3,4]
map (\x -> x > 2) [1,2,3,4]
foldr
foldl' --prefer foldl' to foldl due to thunk space issues

*** Modules
module *name* 
(
   exportedValues
   , ExportedType(...) --adds constructors
) where
*definitions*

*** Typeclasses:
definition:
class BasicEq a where
	isEqual :: a -> a -> Bool
    isEqual x y = not (isNotEqual x y)

    isNotEqual :: a -> a -> Bool
    isNotEqual x y = not (isEqual x y)


instantiation:
instance BasicEq Bool where
	isEqual True  True  = True
    isEqual False False = True
    isEqual _     _     = False

instance (Typeclass) (DataType) where
	(functions)

**** Automatic derivation:
can occur for Read, Show, Bounded, Enum, Eq, Ord

*** Simple Lambda pattern matching:
data Test = Something Int Int
let a = Test 5 3
let myFunc = \x -> case x of Something a b -> a + b

*** Pattern Guards
    guardTest :: Int -> Int
    guardTest x 
	  | x < 5 = 10
	  | x > 5 = 5
	  | otherwise = 0

*** Random Numbers
    import System.Random
    getRandomList :: Float -> Float -> Int -> [Float]
    getRandomList min max seed = randList
      where baseList = randoms (mkStdGen seed) :: [Float]
        range = max - min
        randList = [ min + (x * range) | x <- baseList ]

*** Switch Statement
    recTest :: [Float] -> [Float] -> [Float]
    recTest base vals = case vals of
	  [] -> base
	  x:xs -> recTest (x*2 : base) xs

*** Modules
    Data.Map 
    Data.Text -- More efficient than string
    Data.Maybe -- has isJust, isNothing...
    Control.Monad (forM, liftM)
    Control.Monad.Trans
    Control.Monad.Writer
    Control.Monad.State
    Control.Monad.Reader


*** Monad Transformers
    import Control.Monad.Identity
    import Control.Monad.Trans
    import Control.Monad.Trans.Identity
    import Control.Monad.Trans.State
    import Control.Monad.IO.Class

**** Example State Monads

     test1 :: State Int Int
     test1 = do
     a <- get
     modify (+1)
     b <- get
     return a

     test2 :: State Int String
     test2 = do
     a <- get
     modify (+1)
     b <- get
     return "blah"

**** State Monads combined:
     test3 :: StateT Integer (StateT String Identity) (Integer, String)
     test3 = do
     modify (+1)
     lift $ modify ( ++ "1")
     a <- get
     b <- lift get
     return (a,b)
    
     go3 = runIdentity $ evalStateT (evalStateT test3 0) "0"
    
**** State with IO
     test4 :: StateT String IO Integer
     test4 = do
     modify (++ "1")
     let a = 5
     lift $ print a
     modify (++ "1")
     let b = 10
     lift (print b)
     return $ a + b
    
     go4 = evalStateT test4 "0"

**** State with data
     data TestState = TestState { num :: Int, name :: String }
    
     test5 :: StateT TestState IO (String, Int)
     test5 = do
     theState <- get;
     lift $ print $ name theState
     put $ theState { name = "blah" }
     lift $ print $ num theState
     upState <- get;
     put $ upState { num = 1 + num upState }
     finalState <- get
     return (name finalState, num finalState)
    
     go5 = evalStateT test5 $ TestState 5 "awef"

**** Reader Monad

     -- Reader
     test6 :: Int -> StateT Int (ReaderT Int IO) Int
     test6 y = do
     val <- get
     x <- lift $ ask
     put $ val + x
     return $ x + y
     
     test7 :: ReaderT Int (StateT Int IO) Int
     test7 = do
     val <- ask
     x <- lift get;
     liftIO $ print val
     liftIO $ print x
     lift $ put $ val + x
     newVal <- lift get
     liftIO $ print newVal
     return newVal
     
     go7 = evalStateT (runReaderT test7 10) 2
     
     
     test8 :: ReaderT [Int] (StateT Int IO) Int
     test8 = do
     otherVal <- test9
     liftIO $ print otherVal
     val <- ask
     liftIO $ print val
     lift $ put $ (val !! 2) + 2
     upVal <- lift $ get
     liftIO $ print upVal
     return $ upVal
     
     test9 = do
     val <- ask
     return $ val !! 3
     
     go8 = evalStateT (runReaderT test8 [1,2,3,4]) 2
     
**** Writer Monad
     test10 :: ReaderT [Int] (WriterT String IO) String
     test10 = do
     v <- ask
     lift $ tell "blah"
     liftIO $ print "----"
     lift $ tell "bloo"
     liftIO $ print v
     liftIO $ print "----"
     lift $ tell "blee"
     lift $ tell "awef"
     return "final"

     go10 = runWriterT (runReaderT test10 [1,2,3,4])
     
     go11 = do
     result <- go10
     print $ snd result
     return $ fst result




** Parsec Notes
   parsers as variables requires the flag -XFlexibleContexts
   use Text.Parsec, Text.Parsec.String, Text.Parsec.Char
   Text.Parsec.Char and Text.Parsec.String simplify types   

   General Parse Call:
   parse $PARSER "$ERROR" "$INPUT"
   
   Satisfy performs tests of chars to accept
   satisfy :: (Char -> Bool) -> Parser Char
   
   Standard Parsers:
   anyChar, space, newline, tab,
   upper, lower, alphaNum, letter, digit, hexDigit, octDigit
   string

   oneOf, noneOf, many, skipMany
   
   to convert to numbers:
   read "1234" :: Integer 

   to ignore a parse:
   void $ parser  

   ignore the second parser:
   x <- p <* whitespace

   Options (to backtrack, wrap with 'try' )
   p <|> p2

   Apply a function to a parse result:
   ctor <$> p

   Write new parsers, use type declaration to hint:
#+begin_src haskell
  var :: Parser (Char, String)
  var = do
    fc <- firstChar
    rest <- many nonFirstChar
    return (fc, rest)
    where
      firstChar = satisfy ( \a -> isLetter a || a == '_' )
      nonFirstChar = satisfy ( \a -> isDigit a || isLetter a || a == '_' )
#+end_src



