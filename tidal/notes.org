* [[Https://tidalcycles.org/][Tidal Cycles]]
  Haskell based pattern language.
  [[file:pattern_library/rhythms.hs::--%20Rhythms:][Pattern Library]]
** Startup and setup
   cabal install tidal
   supercollider install SuperDirt quark
   sounds are in ~/Library/Application Support/Supercollider/downloaded-quarks
   Tidal mode for haskell, sclang mode for supercollider
   Make sure to have the SuperDirt quark in the search paths of the yaml config for sc.
   Start Supercollider with sclang-start, then run SuperDirt.start
   Run Tidal with C-c C-s, 
   Run lines of tidal with C-c C-c
   Run multiple lines with C-c C-r, C-RET, or C-c C-e
   *Don't use tidal-run-region its broken*
   *Be careful, default tidal.el :load's files*

** Simple sounds
   #+begin_src tidal
   d1 $ sound "bd"
   d1 silence
   #+end_src
** Concepts
   d1 - d9 voices.
   m1 - m4 for midi channels

   sound : create a pattern of sound samples
   "bd" - pattern of a single bass drum

   "bd:3" - select the third sample from the bd pattern
   "bd" # n "3" - alternative version of sample select

   hush - silence everything

   "[a b c]" - group within a subdivision. Still sequential. can be nested
   
   "<a b c>" - only play one each cycle

   "a*2" - repeat 2 times. Functionally: "a a"
   "a/2" - half as many times. 

   rev - reverse a pattern
   every n func pattern - apply the func to the pattern every n times
   
   fast n, slow n - slow by the amount. slow 0.25 == fast 4

   a # b - apply b to pattern a.
   
   a # crush "4" - apply the crush effect to a
   
   Effects include: crush, speed, delay,
   gain - range 0 to 1
   pan - range 0 to 1
   shape - range 0 to 1
   vowel - a e i o u
   n = the sample number
   off

   |=| applies patterns
   |*| multiplies them

** Midi
   use: [[https://tidalcycles.org/index.php/SuperDirt_MIDI_Tutorial][SuperDirt Midi]]

   #+NAME: Midi Example
   #+begin_src tidal :results value
   d1 $ n "[c3 c3, ~ c5, e7*6]" # s "midi"

   -- Sending CC params:
   d2 $ ccv 64 # ccn 20 # s "midi"
   #+end_src




** Misc Notes
   #+begin_src tidal
     -- Polyrhythm:
     "[bd bd bd, sd cp sd cp]"
     --Polymetre : 
     "{bd bd bd, sd cp sd cp}"
   #+end_src
** useful definitions
   #+begin_src haskell
     -- Convert beats per minute in bars to cycles per second
     bpmToCps n b = n/60/b
   #+end_src
   
   use `realToFrac` fmapped to [int] -> [double]
   use toScale to fit to a scale
   
   #+begin_src haskell
     chordPattern chds = realToFrac `fmap` (Chords.enchord [chd] 0 0)
     --applying a run to a scale
     sound "pluck*6" # up (realToFrac `fmap` (toScale Scales.harmonicMinor "0 1 2 3 4 5"))
     --applying a chord to 
     sound "pluck*5" # up "2" |+| up (realToFrac `fmap` Chords.enchord [Chords.five] 0 0)
     -- up $ chordPattern [Chords.five] # sound "pluck"
   #+end_src

** Rhythms
   (2,5) : A thirteenth century Persian rhythm called Khafif-e-ramal.
   (3,4) : The archetypal pattern of the Cumbia from Colombia, as well as a Calypso rhythm from Trinidad.
   (3,5,2) : Another thirteenth century Persian rhythm by the name of Khafif-e-ramal, as well as a Rumanian folk-dance rhythm.
   (3,7) : A Ruchenitza rhythm used in a Bulgarian folk-dance.
   (3,8) : The Cuban tresillo pattern.
   (4,7) : Another Ruchenitza Bulgarian folk-dance rhythm.
   (4,9) : The Aksak rhythm of Turkey.
   (4,11) : The metric pattern used by Frank Zappa in his piece titled Outside Now.
   (5,6) : Yields the York-Samai pattern, a popular Arab rhythm.
   (5,7) : The Nawakhat pattern, another popular Arab rhythm.
   (5,8) : The Cuban cinquillo pattern.
   (5,9) : A popular Arab rhythm called Agsag-Samai.
   (5,11) : The metric pattern used by Moussorgsky in Pictures at an Exhibition.
   (5,12) : The Venda clapping pattern of a South African children’s song.
   (5,16) : The Bossa-Nova rhythm necklace of Brazil.
   (7,8) : A typical rhythm played on the Bendir (frame drum).
   (7,12) : A common West African bell pattern.
   (7,16,14) : A Samba rhythm necklace from Brazil.
   (9,16) : A rhythm necklace used in the Central African Republic.
   (11,24,14) : A rhythm necklace of the Aka Pygmies of Central Africa.
   (13,24,5) : Another rhythm necklace of the Aka Pygmies of the upper Sangha.

** Patterns
   "[hh hh hh, [bd bd:4]*0.5, [~ sn:4]*0.75]"
   d1 $  (sound "{pluck ~, pluck ~ pluck ~ ~}") |*| (up (realToFrac `fmap` toScale Scales.harmonicMajor "[0 4 5 8 7 3 2]*0.2"))
   d1 $ sound "[pluck(11,24, 14)]*0.25" # up (realToFrac `fmap` toScale Scales.melodicMinor "[2 0 0 3 0 2]")
   d1 $ sound "bd*16" # gain (slow 8 $ sine)
   d1 $ sound "moog*4" # cutoff (scale 300 1000 $ slow 4 $ sine) # sustain 0.3 # release sine

   conditional logic example:
   d1 $ every 5 (|+| speed 0.5) $ every 4 (0.25 <~) $ every 3 (rev) $ sound "bd sn arpy*2 cp"

** Pattern transformation
   #+begin_src tidal
   -- |+| |*| |-| |/|  (|=| or #)
   #+end_src
   rev p
   every n func p
   slow p   |   fast p
   gain, pan, shape, vowel, speed, crush,  (Sound.Tidal.Params)
   n (sample select)

   scale
   sine (continuous)
   saw, tri, square
   density

   <~ and ~> : shift in time

   Randomness: rand and irand. Can be scaled etc
   
   ? in a pattern marks it as degradable. function: degrade.
   degradeBy n $ - controllable possibility degrade


   sometimesBy n func $
   sometimes = sometimesBy 0.5
   often = sometimesBy 0.75
   rarely = sometimesBy 0.25
   almostNever = sometimesBy 0.1
   almostAlways = sometimesBy 0.9

   conditional logic:
   every n (func) $
   whenmod

   use *const* to replace a pattern:
   d1 $ whenmod 8 6 (const $ sound "arpy(3,8) bd*4") $ sound "bd sn bass2 sn"

   sequence patterns with:
   *fastcat* (all into one measure) 
   *cat* (multiple measures)
   *randcat* (choose from available patterns)

   *stack* plays at the same time

   force mono using *cut*

   *transitions*:
   use the associated transition channels (d1-dn : t1-tn)
   send functions like anticipate

** Combining with (#):
   The rule is, for each value in the pattern on
   the left, values from the right are matched where the start (or
   onset) of the left value, fall within the timespan of the value on
   the right. For example, the second pan value of 1 starts one third
   into its pattern, and the second sound value of sn starts one
   quarter into its pattern, and ends at the halfway point. Because
   the former onset (one third) falls inside the timespan of the
   latter timespan (from one quarter until one half), they are
   matched. The timespan of arpy doesn’t contain any onsets from the
   pan pattern, and so it doesn’t match with anything, and isn’t
   played.
* Scales
  #+begin_src haskell
  -- scaleP :: Num a => Pattern String -> Pattern Int -> Pattern a
  -- Scales.scaleTable :: Num a => [(String, [a])]
  #+end_src

** Scales.aeolian :: Num a => [a]
** Scales.ahirbhairav :: Num a => [a]
** Scales.augmented :: Num a => [a]
** Scales.augmented2 :: Num a => [a]
** Scales.bartok :: Num a => [a]
** Scales.bhairav :: Num a => [a]
** Scales.chinese :: Num a => [a]
** Scales.chromatic :: Num a => [a]
** Scales.diminished :: Num a => [a]
** Scales.diminished2 :: Num a => [a]
** Scales.dorian :: Num a => [a]
** Scales.egyptian :: Num a => [a]
** Scales.enigmatic :: Num a => [a]
** Scales.gong :: Num a => [a]
** Scales.harmonicMajor :: Num a => [a]
** Scales.harmonicMinor :: Num a => [a]
** Scales.hexAeolian :: Num a => [a]
** Scales.hexDorian :: Num a => [a]
** Scales.hexMajor6 :: Num a => [a]
** Scales.hexMajor7 :: Num a => [a]
** Scales.hexPhrygian :: Num a => [a]
** Scales.hexSus :: Num a => [a]
** Scales.hindu :: Num a => [a]
** Scales.hirajoshi :: Num a => [a]
** Scales.hungarianMinor :: Num a => [a]
** Scales.indian :: Num a => [a]
** Scales.ionian :: Num a => [a]
** Scales.iwato :: Num a => [a]
** Scales.jiao :: Num a => [a]
** Scales.kumai :: Num a => [a]
** Scales.leadingWhole :: Num a => [a]
** Scales.locrian :: Num a => [a]
** Scales.locrianMajor :: Num a => [a]
** Scales.lydian :: Num a => [a]
** Scales.lydianMinor :: Num a => [a]
** Scales.majPent :: Num a => [a]
** Scales.major :: Num a => [a]
** Scales.marva :: Num a => [a]
** Scales.melodicMajor :: Num a => [a]
** Scales.melodicMinor :: Num a => [a]
** Scales.melodicMinorDesc :: Num a => [a]
** Scales.minPent :: Num a => [a]
** Scales.minor :: Num a => [a]
** Scales.mixolydian :: Num a => [a]
** Scales.neapolitanMajor :: Num a => [a]
** Scales.neapolitanMinor :: Num a => [a]
** Scales.pelog :: Num a => [a]
** Scales.phrygian :: Num a => [a]
** Scales.prometheus :: Num a => [a]
** Scales.purvi :: Num a => [a]
** Scales.ritusen :: Num a => [a]
** Scales.romanianMinor :: Num a => [a]
** Scales.scriabin :: Num a => [a]
** Scales.shang :: Num a => [a]
** Scales.spanish :: Num a => [a]
** Scales.superLocrian :: Num a => [a]
** Scales.todi :: Num a => [a]
** Scales.whole :: Num a => [a]
** Scales.yu :: Num a => [a]
** Scales.zhi :: Num a => [a]

* Chords
	#+begin_src haskell
    Chords.enchord :: Num a => [[a]] -> Pattern a -> Pattern Int -> Pattern a
    Chords.enchord [Chords.major] "c e g" "0"
    -- Chords.chordate :: Num b => [[b]] -> b -> Int -> [b]
    -- Chords.chordTable :: Num a => [(String, [a])]
    -- Chords.chordL :: Num a => Pattern String -> Pattern [a]
    -- chord :: Num a => Pattern String -> Pattern a
    -- Chords.arpg :: Num a => Pattern String -> Pattern a
	#+end_src

** Chords.aug :: Num a => [a]
** Chords.dim :: Num a => [a]
** Chords.dim7 :: Num a => [a]
** Chords.dom7 :: Num a => [a]
** Chords.eleven :: Num a => [a]
** Chords.evelenSharp :: Num a => [a]
** Chords.five :: Num a => [a]
** Chords.m11 :: Num a => [a]
** Chords.m11sharp :: Num a => [a]
** Chords.m13 :: Num a => [a]
** Chords.m6 :: Num a => [a]
** Chords.m6by9 :: Num a => [a]
** Chords.m7flat5 :: Num a => [a]
** Chords.m7flat9 :: Num a => [a]
** Chords.m7sharp5 :: Num a => [a]
** Chords.m7sharp5flat9 :: Num a => [a]
** Chords.m7sharp9 :: Num a => [a]
** Chords.m9 :: Num a => [a]
** Chords.m9sharp5 :: Num a => [a]
** Chords.maj11 :: Num a => [a]
** Chords.maj9 :: Num a => [a]
** Chords.major :: Num a => [a]
** Chords.major7 :: Num a => [a]
** Chords.minor :: Num a => [a]
** Chords.minor7 :: Num a => [a]
** Chords.msharp5 :: Num a => [a]
** Chords.nine :: Num a => [a]
** Chords.nineSharp5 :: Num a => [a]
** Chords.nineSus4 :: Num a => [a]
** Chords.one :: Num a => [a]
** Chords.plus :: Num a => [a]
** Chords.sevenFlat10 :: Num a => [a]
** Chords.sevenFlat5 :: Num a => [a]
** Chords.sevenFlat9 :: Num a => [a]
** Chords.sevenSharp5 :: Num a => [a]
** Chords.sevenSharp5flat9 :: Num a => [a]
** Chords.sevenSus2 :: Num a => [a]
** Chords.sevenSus4 :: Num a => [a]
** Chords.sharp5 :: Num a => [a]
** Chords.six :: Num a => [a]
** Chords.sixby9 :: Num a => [a]
** Chords.sus2 :: Num a => [a]
** Chords.sus4 :: Num a => [a]
** Chords.thirteen :: Num a => [a]

* SuperDirt Sample names
   [[file:~/Library/Application%20Support/SuperCollider/downloaded-quarks/Dirt-Samples][Sample Folder]]
   808
   808bd
   808cy
   808hc
   808ht
   808lc
   808lt
   808mc
   808mt
   808oh
   808sd
   909
   ab
   ade
   ades2
   ades3
   ades4
   alex
   alphabet
   amencutup
   armora
   arp
   arpy
   auto
   baa
   baa2
   bass
   bass0
   bass1
   bass2
   bass3
   bassdm
   bassfoo
   battles
   bd
   bend
   bev
   bin
   birds3
   bleep
   blip
   blue
   bottle
   breaks125
   breaks152
   breaks157
   breaks165
   breath
   bubble
   can
   casio
   cb
   cc
   chin
   chink
   circus
   clak
   click
   co
   cosmicg
   cp
   cr
   crow
   d
   db
   diphone
   diphone2
   dist
   dork2
   dorkbot
   dr
   dr2
   dr55
   dr_few
   drum
   drumtraks
   e
   east
   electro1
   erk
   f
   feel
   feelfx
   fest
   fire
   flick
   foo
   future
   gab
   gabba
   gabbaloud
   gabbalouder
   glasstap
   glitch
   glitch2
   gretsch
   h
   hand
   hardcore
   haw
   hc
   hh
   hh27
   hit
   hmm
   ho
   house
   ht
   if
   ifdrums
   incoming
   industrial
   insect
   invaders
   jazz
   jungbass
   jungle
   jvbass
   koy
   kurt
   latibro
   led
   less
   lighter
   lt
   made
   made2
   mash
   mash2
   metal
   miniyeah
   moan
   monsterb
   moog
   mouth
   mp3
   msg
   mt
   mute
   newnotes
   noise
   noise2
   notes
   numbers
   oc
   odx
   off
   pad
   padlong
   pebbles
   perc
   peri
   pluck
   print
   proc
   procshort
   psr
   rave
   rave2
   ravemono
   rm
   rs
   sax
   sd
   seawolf
   sequential
   sf
   sheffield
   short
   sid
   sine
   sitar
   sn
   space
   speech
   speechless
   speedupdown
   stab
   stomp
   subroc3d
   sugar
   sundance
   tabla
   tabla2
   tablex
   tacscan
   tech
   techno
   tink
   tok
   toys
   trump
   ul
   ulgab
   uxay
   v
   voodoo
   wind
   wobble
   world
   xmas
   yeah

* Reference:
  Taken from [[https://tidalcycles.org/functions.html][TidalCycles Reference]]
** Arithmetic
   #+begin_src tidal
   d1 $ sound "bd*2 [bd [sn sn*2 sn] sn]" # speed ((*2) <$> sine)
   -- or in Tidal 0.9+:
   --Put Patterns on the Left and Arithmetic on the right
   d1 $ sound "bd*2 [bd [sn sn*2 sn] sn]" # speed (sine*2)
   #+end_src

** Palindrome
   palindrome applies rev to a pattern every other cycle, so that the
   pattern alternates between forwards and backwards.

   #+begin_src tidal
   d1 $ palindrome $ sound "arpy:0 arpy:1 arpy:2 arpy:3"
   #+end_src

** brak :: Pattern a -> Pattern a
   Make a pattern sound a bit like a breakbeat. It does this by every
   other cycle, squashing the pattern to fit half a cycle, and offsetting
   it by a quarter of a cycle.

   #+begin_src tidal
   d1 $ brak $ sound "[feel feel:3, hc:3 hc:2 hc:4 ho:1]"
   #+end_src

** degrade :: Pattern a -> Pattern a
   degrade randomly removes events from a pattern 50% of the time.
   The shorthand syntax for degrade is a question mark: ?. 
  
   #+begin_src tidal
   d1 $ slow 2 $ degrade $ sound "[[[feel:5*8,feel*3] feel:3*8], feel*4]"
   -- Sugared:
   d1 $ slow 2 $ sound "bd ~ sn bd ~ bd? [sn bd?] ~"
   d1 $ slow 2 $ sound "[[[feel:5*8,feel*3] feel:3*8]?, feel*4]"
   #+end_src

** degradeBy :: Double -> Pattern a -> Pattern a
   Controls % of events removed

   #+begin_src tidal
        d1 $ slow 2 $ degradeBy 0.9 $ sound "[[[feel:5*8,feel*3] feel:3*8], feel*4]" # accelerate "-6" # speed "2"
   #+end_src

** fast :: Pattern Time -> Pattern a -> Pattern a
  
   Speed up a pattern. For example, the following will play the sound
   pattern "bd sn kurt" twice as fast (i.e. so it repeats twice per
   cycle), and the vowel pattern three times as fast:

   #+begin_src tidal
   d1 $ sound (fast 2 "bd sn kurt") # fast 3 (vowel "a e o")
   #+end_src

   You can also use this function by its older alias, density.
   See also slow.
  
** fit :: Int -> [a] -> Pattern Int -> Pattern a
  
   The fit function takes a pattern of integer numbers, which are used to
   select values from the given list. What makes this a bit strange is
   that only a given number of values are selected each cycle. For
   example:
  
   #+begin_src tidal
      d1 $ sound (fit 3 ["bd", "sn", "arpy", "arpy:1", "casio"] "0 [~ 1] 2 1")
   #+end_src


   The above fits three samples into the pattern, i.e. for the first
   cycle this will be "bd", "sn" and "arpy", giving the result "bd [~ sn]
   arpy sn" (note that we start counting at zero, so that 0 picks the
   first value). The following cycle the next three values in the list
   will be picked, i.e. "arpy:1", "casio" and "bd", giving the pattern
   "arpy:1 [~ casio] bd casio" (note that the list wraps round here).
  
** fit' :: Time -> Int -> Pattern Int -> Pattern Int -> Pattern a -> Pattern a
  
   fit' is a generalization of fit, where the list is instead constructed
   by using another integer pattern to slice up a given pattern. The
   first argument is the number of cycles of that latter pattern to use
   when slicing. It’s easier to understand this with a few examples:
   
   #+begin_src tidal
   d1 $ sound (fit' 1 2 "0 1" "1 0" "bd sn")
   #+end_src

  
   So what does this do? The first 1 just tells it to slice up a single
   cycle of "bd sn". The 2 tells it to select two values each cycle, just
   like the first argument to fit. The next pattern "0 1" is the “from”
   pattern which tells it how to slice, which in this case means "0" maps
   to "bd", and "1" maps to "sn". The next pattern "1 0" is the “to”
   pattern, which tells it how to rearrange those slices. So the final
   result is the pattern "sn bd".
  
   A more useful example might be something like:
   #+begin_src tidal
     d1 $ fit' 1 4 (run 4) "[0 3*2 2 1 0 3*2 2 [1*8 ~]]/2" $ chop 4 $ (sound "breaks152" # unit "c")
   #+end_src
   which uses chop to break a single sample into individual pieces, which
   fit' then puts into a list (using the run 4 pattern) and reassembles
   according to the complicated integer pattern.
  
** iter :: Pattern Int -> Pattern a -> Pattern a
  
   Divides a pattern into a given number of subdivisions, plays the
   subdivisions in order, but increments the starting subdivision each
   cycle. The pattern wraps to the first subdivision after the last
   subdivision is played.
  
   Example:
   d1 $ iter 4 $ sound "bd hh sn cp"
  
   This will produce the following over four cycles:
   bd hh sn cp hh sn cp bd sn cp bd hh cp bd hh sn
  
   The jux function creates strange stereo effects, by applying a
   function to a pattern, but only in the right-hand channel. For
   example, the following reverses the pattern on the righthand side:
  
   d1 $ slow 32 $ jux (rev) $ striate' 32 (1/16) $ sound "bev"
  
   When passing pattern transforms to functions like jux and every, it’s
   possible to chain multiple transforms together with ., for example
   this both reverses and halves the playback speed of the pattern in the
   righthand channel:
  
   d1 $ slow 32 $ jux ((# speed "0.5") . rev) $ striate' 32 (1/16) $ sound "bev"
  
   With jux, the original and effected versions of the pattern are panned
   hard left and right (i.e., panned at 0 and 1). This can be a bit much,
   especially when listening on headphones. The variant juxBy has an
   additional parameter, which brings the channel closer to the
   centre. For example:
  
   d1 $ juxBy 0.5 (fast 2) $ sound "bd sn:1"
  
   In the above, the two versions of the pattern would be panned at 0.25
   and 0.75, rather than 0 and 1.
  
** linger :: Pattern Time -> Pattern a -> Pattern a
  
   Similar to trunc, in that it truncates a pattern so that only the
   first fraction of the pattern is played. However unlike trunk, linger
   repeats that part to fill the remainder of the cycle.
  
   The following example plays only the first three quarters of the
   pattern. For example this repeats the first quarter, so you only hear
   a single repeating note:
  
   d1 $ linger 0.25 $ n "0 2 [3 4] 2" # sound "arpy"
  
   or slightly more interesting, applied only every fourth cycle:
  
   d1 $ every 4 (linger 0.25) $ n "0 2 [3 4] 2" # sound "arpy"
  
   or to a chopped-up sample:
  
   d1 $ every 2 (linger 0.25) $ loopAt 2 $ chop 8 $ sound "breaks125"
  
   You can also pattern the first parameter, for example to cycle through
   three values, one per cycle:
  
   d1 $ trunc "<0.75 0.25 1>" $ sound "bd sn:2 [mt rs] hc"
  
   d1 $ linger "<0.25 0.5 1>" $ loopAt 2 $ chop 8 $ sound "breaks125"
  
** (<~) :: Pattern Time -> Pattern a -> Pattern a
   and:
   (~>) :: Pattern Time -> Pattern a -> Pattern a
  
   (The above means that <~ and ~> are functions that are given a time
   pattern and a pattern of any type, and returns a pattern of the same
   type.)
  
   Shifts a pattern either forward or backward in time.
  
   For example, to shift a pattern by a quarter of a cycle, every fourth
   cycle:
  
   d1 $ every 4 (0.25 <~) $ sound ("arpy arpy:1 arpy:2 arpy:3")
  
   d1 $ every 4 (0.25 ~>) $ sound ("bd ~ sn:1 [mt ht]")
  
   Or to alternate between different shifts:
  
   d1 $ "<0 0.5 0.125>" <~ sound ("arpy arpy:1 arpy:2 arpy:3")
  
** rev :: Pattern a -> Pattern a
  
   Reverse every cycle of a pattern. For example:
  
   d1 $ slow 2 $ rev $ n "0 1 2 3" # sound "numbers"
  
   Or in a conditional:
  
   d1 $ slow 2 $ every 3 (rev) $ n "0 1 2 3" # sound "numbers"
  
** scramble :: Int -> Pattern a -> Pattern a
  
   scramble n p divides the pattern p into n equal parts, and then
   creates a new pattern each cycle by randomly selecting from the
   parts. This could also be called “sampling with replacement”. For
   example,
  
   d1 $ sound $ scramble 3 "bd sn hh"
  
   will sometimes play "sn bd hh" or "hh sn bd", but can also play "bd sn
   bd" or "hh hh hh", because it can make any random combination of the
   three parts.
  
** shuffle :: Int -> Pattern a -> Pattern a
  
   shuffle n p divides the pattern p into n equal parts, and then creates
   a new pattern each cycle by selecting a random permutation of those
   parts. This could also be called “sampling without replacement”. For
   example,
  
   d1 $ sound $ shuffle 3 "bd sn hh"
  
   will sometimes play "sn bd hh" or "hh sn bd" or "hh bd sn". But it can
   never play "hh hh hh", because that isn’t a permutation of the three
   parts.
  
** slow :: Pattern Time -> Pattern a -> Pattern a
  
   Slow down a pattern.
  
   Example:
  
   d1 $ sound (slow 2 "bd sn kurt") # slow 3 (vowel "a e o")
  
   Slow also accepts numbers between 0 and 1, which causes the pattern to
   speed up:
  
   d1 $ sound (slow 0.5 "bd sn kurt") # slow 0.75 (vowel "a e o")
  
   Also, see fast.
  
** smash :: Int -> [Time] -> ParamPattern -> ParamPattern
  
   Smash is a combination of spread and striate - it cuts the samples
   into the given number of bits, and then cuts between playing the loop
   at different speeds according to the values in the list.
  
   So this:
  
   d1 $ smash 3 [2,3,4] $ sound "ho ho:2 ho:3 hc"
  
   Is a bit like this:
  
   d1 $ slow "<2 3 4>" $ striate 3 $ sound "ho ho:2 ho:3 hc"
  
   The spread function allows you to take a pattern transformation which
   takes a parameter, such as slow, and provide several parameters which
   are switched between. In other words it ‘spreads’ a function across
   several values.
  
   Taking a simple high hat loop as an example:
  
   d1 $ sound "ho ho:2 ho:3 hc"
  
   We can slow it down by different amounts, such as by a half:
  
   d1 $ slow 2 $ sound "ho ho:2 ho:3 hc"
  
   Or by four thirds (i.e. speeding it up by a third; 4/3 means four over
   three):
  
   d1 $ slow (4/3) $ sound "ho ho:2 ho:3 hc"
  
   But if we use spread, we can make a pattern which alternates between
   the two speeds:
  
   d1 $ spread slow [2,4/3] $ sound "ho ho:2 ho:3 hc"
  
   There is a nice trick you can use here – if you pass ($) as the
   function to spread values over, you can put functions in the list
   instead of values. For example:
  
   d1 $ spread ($) [fast 2, rev, slow 2, striate 3, (# speed "0.8")] $ sound "[bd*2 [~ bd]] [sn future]*2 cp jvbass*4"
  
   Above, the pattern will have these transforms applied to it, one at a
   time, per cycle:
  
   cycle 1: fast 2 - pattern will increase in speed 
   cycle 2: rev - pattern will be reversed 
   cycle 3: slow 2 - pattern will decrease in speed 
   cycle 4: striate 3 - pattern will be granualized 
   cycle 5: (# speed "0.8") - pattern samples will be played back more slowly
  
   After (# speed "0.8"), the transforms will repeat and start at fast 2
   again.
  
** spread :: (a -> t -> Pattern b) -> [a] -> t -> Pattern b
  
   (The above is difficult to describe, if you don’t understand Haskell,
   just ignore it and read the below..)
  
   The spread function allows you to take a pattern transformation which
   takes a parameter, such as slow, and provide several parameters which
   are switched between. In other words it ‘spreads’ a function across
   several values.
  
   Taking a simple high hat loop as an example:
  
   d1 $ sound "ho ho:2 ho:3 hc"
  
   We can slow it down by different amounts, such as by a half:
  
   d1 $ slow 2 $ sound "ho ho:2 ho:3 hc"
  
   Or by four thirds (i.e. speeding it up by a third; 4/3 means four over
   three):
  
   d1 $ slow (4/3) $ sound "ho ho:2 ho:3 hc"
  
   But if we use spread, we can make a pattern which alternates between
   the two speeds:
  
   d1 $ spread slow [2,4/3] $ sound "ho ho:2 ho:3 hc"
  
   In recent versions of tidal, you can actually do without the spread
   and instead pass a pattern of parameters straight to the function:
  
   d1 $ slow "<2 4/3>" $ sound "ho ho:2 ho:3 hc"
  
   One advantage of this is that you can provide polyphonic parameters,
   e.g.:
  
   d1 $ slow "<2 4/3, 3>" $ sound "ho ho:2 ho:3 hc"
  
   This is quite experimental and might not work with all functions yet.
  
   There’s another version of spread called fastspread. True to its name,
   the result is faster, because it squeezes all the variations into one
   cycle. As the following gives two parameters to slow, it goes twice as
   fast as if you’d used spread:
  
   d1 $ fastspread slow [2,4/3] $ sound "ho ho:2 ho:3 hc"
  
   In previous versions of Tidal, spread was actually the same as
   fastspread. Now, slowspread is an alias of spread, but you may as well
   type the latter, as it’s shorter!
  
** toScale::[Int] -> Pattern Int -> Pattern Int
  
   The toScale function lets you turn a pattern of notes within a scale
   (expressed as a list) to note numbers. For example
  
   d1 $ n (toScale [0, 4, 7] "0 1 2 3") # sound "supermandolin"
  
   will turn the pattern "0 1 2 3" into the pattern "0 4 7 12" by
   “picking” those notes out of the provided scale [0, 4, 7].
  
   toScale assumes your scale repeats after a single octave, if it
   doesn’t you can use a primed version toScale' size. For example
  
   toscale' 24 [0,4,7,10,14,17] (run 8)
  
   turns into "0 4 7 10 14 17 24 28"
  
   A large number of scale and chord names have been provided in the
   Sound.Tidal.Chords and Sound.Tidal.Scales modules. If not already
   loaded, you can gain access to these with a command like
  
   import qualified Sound.Tidal.Scales as Scales
  
   and then use them as Scales.ionian, Scales.dorian, Scales.phrygian,
   etc…
  
** trunc :: Pattern Time -> Pattern a -> Pattern a
  
   Truncates a pattern so that only a fraction of the pattern is
   played. The following example plays only the first three quarters of
   the pattern:
  
   d1 $ trunc 0.75 $ sound "bd sn*2 cp hh*4 arpy bd*2 cp bd*2"
  
   You can also pattern the first parameter, for example to cycle through
   three values, one per cycle:
  
   d1 $ trunc "<0.75 0.25 1>" $ sound "bd sn:2 [mt rs] hc"
  
   See also linger.
  
** zoom :: Arc -> Pattern a -> Pattern a
  
   Plays a portion of a pattern, specified by the beginning and end of a
   time span (known as an ‘arc’). The new resulting pattern is played
   over the time period of the original pattern:
  
   d1 $ zoom (0.25, 0.75) $ sound "bd*2 hh*3 [sn bd]*2 drum"
  
   In the pattern above, zoom is used with an arc from 25% to 75%. It is
   equivalent to this pattern:
  
   d1 $ sound "hh*3 [sn bd]*2"
  
   Here’s an example of it being used with a conditional:
  
   d1 $ every 4 (zoom (0.25, 0.75)) $ sound "bd*2 hh*3 [sn bd]*2 drum"
  
   The following functions manipulate each sample within a pattern, some
   granularize them, others echo.
  
   loopAt makes sample fit the given number of cycles. Internally, it
   works by setting the unit parameter to “c”, changing the playback
   speed of the sample with the speed parameter, and setting setting the
   density of the pattern to match.
  
   d1 $ loopAt 4 $ sound "breaks125"
  
   It’s a good idea to use this in conjuction with chop, so the break is
   chopped into pieces and you don’t have to wait for the whole sample to
   start/stop.
  
   d1 $ loopAt 4 $ chop 32 $ sound "breaks125"
  
   Like all tidal functions, you can mess about with this
   considerably. The below example shows how you can supply a pattern of
   cycle counts to loopAt:
  
   d1 $ juxBy 0.6 (|*| speed "2") $ loopAt "<4 6 2 3>" $ chop 12 $ sound "fm:14"
  
** gap :: Int -> ParamPattern -> ParamPattern
  
   gap is similar to chop in that it granualizes every sample in place as
   it is played, but every other grain is silent. Use an integer value to
   specify how many granules each sample is chopped into:
  
   d1 $ gap 8 $ sound "jvbass"
  
   d1 $ gap 16 $ sound "[jvbass drum:4]"
  
   You can also provide a pattern here:
  
   d1 $ gap "<32 16 8 4>" $ sound "rave"
  
** chop :: Pattern Int -> ParamPattern -> ParamPattern
  
   chop granualizes every sample in place as it is played, turning a
   pattern of samples into a pattern of sample parts. Use an integer
   value to specify how many granules each sample is chopped into:
  
   d1 $ chop 16 $ sound "arpy ~ feel*2 newnotes"
  
   You can pattern that first parameter:
  
   d1 $ chop "<16 128 32>" $ sound "arpy ~ feel*2 newnotes"
  
   You end up with a pattern of the chopped up bits of samples, so for
   example if you then reverse the pattern, you reverse the order of the
   bits:
  
   d1 $ slow 2 $ rev $ chop 16 $ sound "breaks125"
  
   Lets try that reverse in just one speaker:
  
   d1 $ slow 2 $ jux rev $ chop 16 $ sound "breaks125"
  
   Different values of chop can yield very different results, depending
   on the samples used:
  
   d1 $ chop 16 $ sound (samples "arpy*8" (run 16)) d1 $ chop 32 $ sound (samples "arpy*8" (run 16)) d1 $ chop 256 $ sound "bd*4 [sn cp] [hh future]*2 [cp feel]"
  
   You can also use chop (or (striate)[#striate]) with very long samples,
   to cut it into short chunks and pattern those chunks. The following
   cuts a sample into 32 parts, and plays it over 8 cycles:
  
   d1 $ loopAt 8 $ chop 32 $ sound "bev"
  
   The loopAt takes care of changing the speed of sample playback so that
   the sample fits in the given number of cycles.
  
   You can’t hear that the sample has been cut into bits in the
   above. This becomes more apparent when you do further manipulations of
   the pattern, for example rev to reverse the order of the cut up bits:
  
   d1 $ loopAt 8 $ rev $ chop 32 $ sound "bev"
  
   See also striate.
  
** striate :: Pattern Int -> ParamPattern -> ParamPattern
  
   Striate is a kind of granulator, cutting samples into bits in a
   similar to (chop)[#chop], but the resulting bits are organised
   differently. For example:
  
   d1 $ slow 4 $ striate 16 $ sound "numbers:0 numbers:1 numbers:2
   numbers:3"
  
   This plays the loop the given number of times, but triggering
   progressive portions of each sample. So in this case it plays the loop
   three times, the first time playing the first third of each sample,
   then the second time playing the second third of each sample,
   etc.. With the highhat samples in the above example it sounds a bit
   like reverb, but it isn’t really.
  
   Compare this with chop:
  
   d1 $ slow 4 $ chop 16 $ sound "numbers:0 numbers:1 numbers:2 numbers:3"
  
   You can hear that the striate version interlaces the cut up bits of
   samples together, whereas the chop version plays each chopped up
   sample in turn. Here’s the samples without any granulation, in case
   that helps understand what’s happening in the above:
  
   d1 $ slow 4 $ sound "numbers:0 numbers:1 numbers:2 numbers:3"
  
   The striate' function is a variant of striate with an extra parameter,
   which specifies the length of each part. The striate' function still
   scans across the sample over a single cycle, but if each bit is
   longer, it creates a sort of stuttering effect. For example the
   following will cut the bev sample into 32 parts, but each will be
   1/16th of a sample long:
  
   d1 $ slow 32 $ striate' 32 (1/16) $ sound "bev"
  
   Note that striate uses the begin and end parameters internally. This
   means that if you’re using striate (or striate') you probably
   shouldn’t also specify begin or end.
  
** striateL :: Int -> Int -> ParamPattern -> ParamPattern
  
   Just like striate, but also loops each sample chunk a number of times
   specified in the second argument. The primed version is just like
   striate', where the loop count is the third argument. For example:
  
   d1 $ striateL' 3 0.125 4 $ sound "feel sn:2"
  
   Like striate, these use the begin and end parameters internally, as
   well as the loop parameter for these versions.
  
** stut :: Integer -> Double -> Rational -> ParamPattern -> ParamPattern
  
   Stut applies a type of delay to a pattern. It has three parameters,
   which could be called depth, feedback and time. Depth is an integer
   and the others floating point. This adds a bit of echo:
  
   d1 $ stut 4 0.5 0.2 $ sound "bd sn"
  
   The above results in 4 echos, each one 50% quieter than the last, with
   1/5th of a cycle between them. It is possible to reverse the echo:
  
   d1 $ stut 4 0.5 (-0.2) $ sound "bd sn"
  
** stut' :: Integer -> Time -> (ParamPattern -> ParamPattern) -> ParamPattern -> ParamPattern
  
   Instead of just decreasing volume to produce echoes, stut' allows to
   apply a function for each step and overlays the result delayed by the
   given time.
  
   d1 $ stut' 2 (1/3) (# vowel "{a e i o u}%2") $ sound "bd sn"
  
   In this case there are two overlays delayed by 1/3 of a cycle, where
   each has the vowel filter applied.
  
   Conditional transformers are functions that apply other
   transformations under certain cirumstances. These can be based upon
   the number of cycles, probability or time-range within a pattern.
  
** someCyclesBy :: Double -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a
  
   Similar to sometimesBy, but applies/doesn’t apply a function on a
   cycle-by-cycle basis instead of event by event. Use someCyclesBy to
   apply a given function for some cycles, but not for others. For
   example, the following code results in fast 2 being applied for about
   25% of all cycles:
  
   d1 $ someCyclesBy 0.25 (fast 2) $ sound "bd*8"
  
   There is an alias as well:
  
   someCycles = someCyclesBy 0.5
  
** foldEvery :: [Int] -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a
  
   foldEvery transforms a pattern with a function, but only for the given
   number of repetitions. It is similar to chaining multiple every
   functions together.
  
   Example:
  
   d1 $ foldEvery [3, 4, 5] (fast 2) $ sound "bd sn kurt"
  
   this is equal to:
  
   d1 $ every 3 (fast 2) $ every 4 (fast 2) $ every 5 (fast 2) $ sound "bd sn kurt"
  
** ifp :: (Int -> Bool) -> (Pattern a -> Pattern a) -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a
  
   Decide whether to apply one or another function depending on the
   result of a test function that is passed the current cycle as a
   number.
  
   d1 $ ifp ((== 0).(flip mod 2)) (striate 4) (# coarse "24 48") $ sound "hh hc"
  
   This will apply striate 4 for every even cycle and aply # coarse "24
   48" for every odd.
  
   Detail: As you can see the test function is arbitrary and does not
   rely on anything tidal specific. In fact it uses only plain haskell
   functionality, that is: it calculates the modulo of 2 of the current
   cycle which is either 0 (for even cycles) or 1. It then compares this
   value against 0 and returns the result, which is either True or
   False. This is what the ifp signature’s first part signifies (Int ->
   Bool), a function that takes a whole number and returns either True or
   False.
  
** mask :: Pattern a -> Pattern b -> Pattern b
  
   Removes events from second pattern that don’t start during an event
   from first.
  
   Consider this, kind of messy rhythm without any rests.
  
   d1 $ sound (cat ["sn*8", "[cp*4 bd*4, hc*5]"]) # n (run 8)
  
   If we apply a mask to it
  
   d1 $ s (mask ("1 1 1 ~ 1 1 ~ 1" :: Pattern Bool) (cat ["sn*8", "[cp*4 bd*4, bass*5]"] )) # n (run 8) 
  
   Due to the use of cat here, the same mask is first applied to "sn*8"
   and in the next cycle to `“[cp4 bd4, hc*5]”.
  
   You could achieve the same effect by adding rests within the cat
   patterns, but mask allows you to do this more easily. It kind of keeps
   the rhythmic structure and you can change the used samples
   independently, e.g.
  
   d1 $ s (mask ("1 ~ 1 ~ 1 1 ~ 1" :: Pattern Bool) (cat ["can*8", "[cp*4 sn*4, jvbass*16]"] )) # n (run 8) 
  
   Detail: It is currently needed to explicitly tell Tidal that the mask
   itself is a Pattern Bool as it cannot infer this by itself, otherwise
   it will complain as it does not know how to interpret your input.
  
** every :: Pattern Int -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a
  
   every transforms a pattern with a function every ‘n’th cycle, where n
   is the value you supply as the first parameter.
  
   For example, to make a pattern twice as fast every third cycle:
  
   d1 $ every 3 (fast 2) $ sound "bd sn kurt"
  
   There is a primed variant with an offset
  
** every' :: Int -> Int -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a
  
   So every' 4 0 will transform a pattern on cycles 0,4,8,… whereas
   every' 4 2 will transform the pattern on cycles 2,6,10,…
  
   Also, see whenmod.
  
** sometimesBy :: Double -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a
  
   Use sometimesBy to apply a given function “sometimes”. For example,
   the following code results in fast 2 being applied about 25% of the
   time:
  
   d1 $ sometimesBy 0.25 (fast 2) $ sound "bd*8"
  
   There are some aliases as well:
  
   sometimes = sometimesBy 0.5 
   often = sometimesBy 0.75 
   rarely = sometimesBy 0.25 
   almostNever = sometimesBy 0.1 
   almostAlways = sometimesBy 0.9 
   never = sometimesBy 0 
   always = sometimesBy 1
  
** swingBy::Time -> Time -> Pattern a -> Pattern a
  
   The function swingBy x n breaks each cycle into n slices, and then
   delays events in the second half of each slice by the amount x, which
   is relative to the size of the (half) slice. So if x is 0 it does
   nothing, 0.5 delays for half the “note” duration, and 1 will wrap
   around to doing nothing again. The end result is a shuffle or
   swing-like rhythm. For example
  
   d1 $ swingBy (1/3) 4 $ sound "hh*8"
  
   will delay every other "hh" 1/3 of the way to the next "hh".
  
   swing is an alias for swingBy (1/3)
  
** when :: (Int -> Bool) -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a
  
   Only when the given test function returns True the given pattern
   transformation is applied. The test function will be called with the
   current cycle as a number.
  
   d1 $ when ((elem '4').show) (striate 4) $ sound "hh hc"
  
   The above will only apply striate 4 to the pattern if the current
   cycle number contains the number 4. So the fourth cycle will be
   striated and the fourteenth and so on. Expect lots of striates after
   cycle number 399.
  
** whenmod :: Int -> Int -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a
  
   whenmod has a similar form and behavior to every, but requires an
   additional number. Applies the function to the pattern, when the
   remainder of the current loop number divided by the first parameter,
   is greater or equal than the second parameter.
  
   For example the following makes every other block of four loops twice
   as dense:
  
   d1 $ whenmod 8 4 (fast 2) (sound "bd sn kurt")
  
** within :: Arc -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a
  
   Use within to apply a function to only a part of a pattern. For
   example, to apply fast 2 to only the first half of a pattern:
  
   d1 $ within (0, 0.5) (fast 2) $ sound "bd*2 sn lt mt hh hh hh hh"
  
   Or, to apply `(# speed “0.5”) to only the last quarter of a pattern:
  
   d1 $ within (0.75, 1) (# speed "0.5") $ sound "bd*2 sn lt mt hh hh hh hh"
  
   Some functions work with multiple sets of patterns, interlace them or
   play them successively.
  
   There is a similar function named seqP which allows you to define when
   a sound within a list starts and ends. The code below contains three
   separate patterns in a “stack”, but each has different start times
   (zero cycles, eight cycles, and sixteen cycles, respectively). In the
   example, ll patterns stop after 12 cycles:
  
   d1 $ seqP [ (0, 12, sound "bd bd*2"), (4, 12, sound "hh*2 [sn cp] cp future*4"), (8, 12, sound (samples "arpy*8" (run 16))) ]
  
   If you run the above, you probably won’t hear anything. This is
   because cycles start ticking up as soon as you start Tidal, and you
   have probably already gone part cycle 12.
  
   You can reset the cycle clock back to zero by running cps (-1)
   followed by cps 1, or whatever tempo you want to restart
   at. Alternatively, you can shift time for the seqP pattern back to
   zero like this:
  
   d1 $ (pure now) ~> seqP [ (0, 12, sound "bd bd*2"), (4, 12, sound "hh*2 [sn cp] cp future*4"), (8, 12, sound (samples "arpy*8" (run 16))) ]
  
   A third option is to use seqPLoop instead, which will keep looping the
   sequence when it gets to the end:
  
   d1 $ (pure now) ~> seqPLoop [ (0, 12, sound "bd bd*2"), (4, 12, sound "hh*2 [sn cp] cp future*4"), (8, 12, sound (samples "arpy*8" (run 16))) ]
  
** cat :: [Pattern a] -> Pattern a
  
   cat, (also known as slowcat) concatenates a list of patterns into a
   new pattern; each pattern in the list will maintain its original
   duration. cat is similar to fastcat, except that pattern lengths are
   not changed. Examples:
  
   d1 $ cat [sound "bd*2 sn", sound "arpy jvbass*2"]
  
   d1 $ cat [sound "bd*2 sn", sound "arpy jvbass*2", sound "drum*2"]
  
   d1 $ cat [sound "bd*2 sn", sound "jvbass*3", sound "drum*2", sound "ht mt"]
  
** fastcat :: [Pattern a] -> Pattern a
  
   fastcat concatenates a list of patterns into a new pattern. The new
   pattern’s length will be a single cycle. Note that the more patterns
   you add to the list, the faster each pattern will be played so that
   all patterns can fit into a single cycle. Examples:
  
   d1 $ fastcat [sound "bd*2 sn", sound "arpy jvbass*2"]
  
   d1 $ fastcat [sound "bd*2 sn", sound "arpy jvbass*2", sound "drum*2"]
  
   d1 $ fastcat [sound "bd*2 sn", sound "jvbass*3", sound "drum*2", sound "ht mt"]
  
** interlace :: ParamPattern -> ParamPattern -> ParamPattern
  
   (A function that takes two ParamPatterns, and blends them together
   into a new ParamPattern. A ParamPattern is basically a pattern of
   messages to a synthesiser.)
  
   Shifts between the two given patterns, using distortion.
  
   Example:
  
   d1 $ interlace (sound "bd sn kurt") (every 3 rev $ sound "bd sn:2")
  
** randcat :: [Pattern a] -> Pattern a
  
   randcat is similar to slowcat, but rather than playing the given
   patterns in order, picks them at random.
  
   d1 $ randcat [sound "bd*2 sn", sound "jvbass*3", sound "drum*2", sound "ht mt"]
  
** append :: Pattern a -> Pattern a -> Pattern a append' :: Pattern a ->  Pattern a -> Pattern a
  
   append combines two patterns into a new pattern, so that the events of
   the second pattern are appended to those of the first pattern, within
   a single cycle.
  
   d1 $ append (sound "bd*2 sn") (sound "arpy jvbass*2")
  
   append' does the same as append, but over two cycles, so that the
   cycles alternate between the two patterns.
  
   d1 $ append' (sound "bd*2 sn") (sound "arpy jvbass*2")
  
** spin :: Int n -> Pattern a -> Pattern a
  
   spin will “spin” a layer up a pattern the given number of times, with
   each successive layer offset in time by an additional 1/n of a cycle,
   and panned by an additional 1/n. The result is a pattern that seems to
   spin around. This function works best on multichannel systems.
  
   d1 $ slow 3 $ spin 4 $ sound "drum*3 tabla:4 [arpy:2 ~ arpy] [can:2 can:3]"
  
** stack :: [Pattern a] -> Pattern a
  
   stack takes a list of patterns and combines them into a new pattern by
   playing all of the patterns in the list simultaneously.
  
   d1 $ stack [ sound "bd bd*2", sound "hh*2 [sn cp] cp future*4", sound (samples "arpy*8" (run 16)) ]
  
   This is useful if you want to use a transform or synth parameter on
   the entire stack:
  
   d1 $ whenmod 5 3 (striate 3) $ stack [ sound "bd bd*2", sound "hh*2 [sn cp] cp future*4", sound (samples "arpy*8" (run 16)) ] # speed "[[1 0.8], [1.5 2]*2]/3"  

** superimpose :: (Pattern a -> Pattern a) -> Pattern a -> Pattern a
  
   superimpose plays a modified version of a pattern at the same time as
   the original pattern, resulting in two patterns being played at the
   same time.
  
   d1 $ superimpose (fast 2) $ sound "bd sn [cp ht] hh"
  
   d1 $ superimpose ((# speed "2") . (0.125 <~)) $ sound "bd sn cp hh"
  
** weave :: Time -> ParamPattern -> [ParamPattern] -> ParamPattern 
   and
   weave' :: Time -> ParamPattern -> [ParamPattern -> ParamPattern] -> ParamPattern
  
   weave applies one parameter pattern to an list of other parameter
   patterns. For example:
  
   d1 $ weave 16 (pan sine) [sound "bd sn cp", sound "casio casio:1", sound "[jvbass*2 jvbass:2]/2", sound "hc*4" ]
  
   What makes this interesting is that the pan sine pattern is offset for
   each of the given sound patterns. The pan sine is slowed down by the
   given number of cycles 16, and because the patterns are offset, they
   seem to chase after each other around the stereo field. Try listening
   on headphones.
  
   You can have it the other way round, and have the effect parameters
   chasing after each other around a sound parameter, like this:
  
   d1 $ weave 16 (sound "arpy*8" # n (run 8)) [vowel "a e i", vowel "i [i o] o u", vowel "[e o]/3 [i o u]/2", speed "1 2 3" ]
  
   weave' is similar in that it blends functions at the same time at
   different amounts over a pattern:
  
   d1 $ weave' 3 (sound "bd [sn drum:2*2] bd*2 [sn drum:1]") [fast 2, (# speed "0.5"), chop 16]
  
** wedge :: Time -> Pattern a -> Pattern a -> Pattern a
  
   wedge combines two patterns by squashing two patterns into a single
   pattern cycle. It takes a ratio as the first argument. The ratio
   determines what percentage of the pattern cycle is taken up by the
   first pattern. The second pattern fills in the remainder of the
   pattern cycle.
  
   d1 $ wedge (1/4) (sound "bd*2 arpy*3 cp sn*2") (sound "odx [feel future]*2 hh hh")
  
** anticipate :: Time -> [ParamPattern] -> ParamPattern
  
   Build up some tension, culminating in a drop to the new pattern after
   8 cycles.  anticipateIn
  
** anticipateIn :: Time -> Time -> [ParamPattern] -> ParamPattern
  
   same as anticipate though it allows you to specify the number of
   cycles until dropping to the new pattern, e.g.:
  
   d1 $ sound "jvbass(3,8)"
  
   t1 (anticipateIn 4) $ sound "jvbass(5,8)"
  
** clutch :: Time -> [Pattern a] -> Pattern a
  
   Degrades the current pattern while undegrading the next.
  
   This is like xfade but not by gain of samples but by randomly removing
   events from the current pattern and slowly adding back in missing
   events from the next one.
  
   d1 $ sound "bd(3,8)"
  
   t1 clutch $ sound "[hh*4, odx(3,8)]"
  
   clutch takes two cycles for the transition, essentially this is
   clutchIn 2.
  
** clutchIn :: Time -> Time -> [Pattern a] -> Pattern a
  
   Also degrades the current pattern and undegrades the next. To change
   the number of cycles the transition takes, you can use clutchIn like
   so:
  
   d1 $ sound "bd(5,8)"
  
   t1 (clutchIn 8) $ sound "[hh*4, odx(3,8)]"
  
   will take 8 cycles for the transition.
  
** histpan :: Int -> Time -> [ParamPattern] -> ParamPattern
  
   Pans the last n versions of the pattern across the field
  
** jump :: Time -> [ParamPattern] -> ParamPattern
  
   Jumps directly into the given pattern, this is essentially the no
   transition-transition.
  
   Variants of jump provide more useful capabilities, see jumpIn and
   jumpMod
  
** jumpIn :: Int -> Time -> [ParamPattern] -> ParamPattern
  
   Does a sharp “jump” cut transition after the specified number of
   cycles have passed.
  
** jumpIn' :: Int -> Time -> [ParamPattern] -> ParamPattern
  
   Does a sharp “jump” cut transition after at least the specified number
   of cycles have passed, but only transitions at a cycle boundary
   (e.g. when the cycle count is an integer)
  
** jumpMod :: Int -> Time -> [ParamPattern] -> ParamPattern
  
   Does a sharp “jump” cut transition the next time the cycle count
   modulo the given integer is zero.
  
** mortal :: Time -> Time -> Time -> [ParamPattern] -> ParamPattern
  
   Degrade the new pattern over time until it ends in silence
  
** superwash :: (Pattern a -> Pattern a) -> (Pattern a -> Pattern a) ->
   Time -> Time -> Time -> Time -> [Pattern a] -> Pattern a
  
   A generalization of wash. Washes away the current pattern after a
   certain delay by applying a function to it over time, then switching
   over to the next pattern to which another function is applied.
  
   d1 $ sound "feel*4 [feel:2 sn:2]"
  
   t1 (superwash (# accelerate "4 2 -2 -4") (striate 2) 1 4 6) $ sound "bd [odx:2 sn/2]"
  
   Note that after one cycle # accelerate "4 2 -2 -4" is applied to sound
   "feel*4 [feel:2 sn:2]" for 4 cycles and then the whole pattern is
   replaced by sound "bd [odx:2 sn/2]" and striate 2 is applied to it for
   6 cycles. Afterwards sound "bd [odx:2 sn/2]" is played normally.
  
** wait :: Time -> Time -> [ParamPattern] -> ParamPattern
  
   Just stop for a bit before playing new pattern
  
** wash :: (Pattern a -> Pattern a) -> Time -> Time -> [Pattern a] ->
   Pattern a
  
   Wash away the current pattern by applying a function to it over time,
   then switching over to the next.
  
   d1 $ sound "feel ! feel:1 feel:2"
  
   t1 (wash (chop 8) 4) $ sound "feel*4 [feel:2 sn:2]"
  
   Note that chop 8 is applied to sound "feel ! feel:1 feel:2" for 4
   cycles and then the whole pattern is replaced by sound "feel*4 [feel:2
   sn:2]
  
** xfade :: Time -> [ParamPattern] -> ParamPattern
  
   Crossfade between old and new pattern over the next two cycles.
  
   d1 $ sound "bd sn"
  
   t1 xfade $ sound "can*3"
  
   xfade is essentially xfadeIn 2 so you can also specify how many cycles
   you want the transition to take: xfadeIn
  
** xfadeIn :: Time -> Time -> [ParamPattern] -> ParamPattern
  
   crossfades between old and new pattern over given number of cycles,
   e.g.:
  
   d1 $ sound "bd sn"
  
   t1 (xfadeIn 16) $ sound "jvbass*3"
  
   Will fade over 16 cycles from “bd sn” to “jvbass*3”
  
** Synth Params

   In general, synth parameters specify patterns of sounds, and patterns
   of effects on those sounds. These are synthesis parameters you can use
   with the default SuperDirt synth or Classic Dirt: a pattern of numbers. 

   In SuperDirt, this is in Hz (try a range between
   0 and 8000). In classic dirt, it is from 0 to 1. Sets the center
   frequency of the band-pass filter. Applies the cutoff frequency of the
   high-pass filter. Has the shorthand form hpf.
  
   a pattern of numbers. In SuperDirt, this is in Hz (try a range between
   0 and 6000). In classic dirt, it is from 0 to 1. Sets the center
   frequency of the band-pass filter. Has the shorthand bpf.
  
   a pattern of numbers that set the q-factor of the band-pass
   filter. Higher values (larger than 1) narrow the band-pass. Has the
   shorthand bpq.
  
   a pattern of numbers from 0 to 1. Skips the beginning of each sample,
   e.g. 0.25 to cut off the first quarter from each sample.
  
   In Classic Dirt, using begin "-1" combined with cut "-1" means that
   when the sample cuts itself it will begin playback from where the
   previous one left off, so it will sound like one seamless sample. This
   allows you to apply a synth param across a long sample in a way
   similar to chop:
  
   cps 0.5
  
   d1 $ sound "breaks125*8" # unit "c" # begin "-1" # cut "-1" # coarse "1 2 4 8 16 32 64 128"
  
   This will play the breaks125 sample and apply the changing coarse
   parameter over the sample. Compare to:
  
   d1 $ (chop 8 $ sounds "breaks125") # unit "c" # coarse "1 2 4 8 16 32 64 128"
  
   which performs a similar effect, but due to differences in
   implementation sounds different.
  
   fake-resampling, a pattern of numbers for lowering the sample rate,
   i.e. 1 for original 2 for half, 3 for a third and so on.
  
   bit crushing, a pattern of numbers from 1 for drastic reduction in
   bit-depth to 16 for barely no reduction.
  
** cut :: Pattern Int -> ParamPattern
  
   In the style of classic drum-machines, cut will stop a playing sample
   as soon as another samples with in same cutgroup is to be played.
  
   An example would be an open hi-hat followed by a closed one,
   essentially muting the open.
  
   d1 $ stack [ sound "bd", sound "~ [~ [ho:2 hc/2]]" # cut "1" ]
  
   This will mute the open hi-hat every second cycle when the closed one
   is played.
  
   Using cut with negative values will only cut the same sample. This is
   useful to cut very long samples
  
   d1 $ sound "[bev, [ho:3](3,8)]" # cut "-1"
  
   Using cut "0" is effectively no cutgroup.
  
   a pattern of numbers. In SuperDirt, this is in Hz (try a range between
   0 and 6000). In classic dirt, it is from 0 to 1. Applies the cutoff
   frequency of the low-pass filter. Has the shorthand form lpf.
  
   a pattern of numbers that set the initial level of the delay
   signal. I.e. a value of one means the first echo will be as loud as
   the original sound.
  
   a pattern of numbers from 0 to 1. Sets the amount of delay feedback.
  
   a pattern of numbers from 0 to 1. Sets the length of the delay.
  
   the same as begin, but cuts the end off samples, shortening them;
   e.g. 0.75 to cut off the last quarter of each sample.
  
   a pattern of numbers that specify volume. Values less than 1 make the
   sound quieter. Values greater than 1 make the sound louder.
  
   a pattern of numbers that speed up (or slow down) samples while they
   play.
  
   a pattern of numbers from 0 to 1. Applies the resonance of the
   high-pass filter. Has the shorthand form hpq.
  
   Controls the length of the sound (called sustain) relative to its
   “space” in the pattern - the time from the beginning of one sound in
   the pattern to the beginning of the next - also known as the
   “inter-onset time”1.
** legato  
   legato "1" means the sound will play for the duration of its “space”
   and then stop playing. For example
  
   d1 $ sound "[[rave rave] rave]" # legato "1"
  
   will play the first two sounds for 1/4 of a cycle, and the third for
   1/2 of a cycle. Other values of legato will multiply that duration,
   such that values greater than 1 will cause the sounds to overlap, and
   values less than one will cause the sounds to end before the next one
   begins.
  
   For softsynths, leaving legato unspecified causes SuperDirt to default
   to legato "1".
  
   For samples, when leaving legato unspecified SuperDirt will play the
   sample for its full duration, whatever that might be.
  
   See also the sustain parameter.
  
   sound), but you can use the delta parameter to override this and
   control it directly. The user-provided delta will then be multiplied
   by legato (if provided) as normal.
  
   loops the sample (from begin to end) the specified number of times.
  
** nudge :: Pattern Double -> ParamPattern
  
   Pushes things forward (or backwards within built-in latency) in
   time. Allows for nice things like swing feeling:
  
   d1 $ stack [ sound "bd bd/4", sound "hh(5,8)" ] # nudge "[0 0.04]*4"
  
   Low values will give a more human feeling, high values might result in
   quite the contrary.
  
   a pattern of numbers between 0 and 1, from left to right (assuming
   stereo)
  
   a pattern of numbers from 0 to 1. Applies the resonance of the
   low-pass filter. Has the shorthand form lpq.
  
   Both room and size are patterns of numbers, representing the amount of
   input into the reverb unit, and notional size of the room
   respectively. These are only available in SuperDirt (not classic dirt)
   and is a fully working but experimental feature which may change in
   the future.
  
   wave shaping distortion, a pattern of numbers from 0 for no distortion
   up to 1 for loads of distortion
  
   a pattern of strings representing sound sample names (required)
  
   A pattern of numbers which multiplies the speed of sample playback,
   where 1 means normal speed. Can be used as a cheap way of changing
   pitch for samples. Negative numbers will cause the sample to be played
   backwards.
  
   When using this method to alter sample pitch, there’s a convenience
   parameter up, which uses units of semitones instead of multiplicative
   values. For example,
  
   d1 $ s "arpy*4" # up "0 4 7 0"
  
   will play the “arpy” sample at the orginal speed, then up 4 semitones
   (a third), then up 7 semitones (a fifth), then once more at the
   original speed.
  
   The behavior of speed can also be changed by the unit parameter.
  
   Sets the duration of the sound in seconds. Primarily used in SuperDirt
   for softsynths, but can be used for samples as well.
  
   accepts values of “r” (default), “c”, or “s”, which controls how the
   speed parameter is interpreted.
  
   With unit "r", speed multiplies the sample playback rate, so 1 is
   normal speed, 2 is double speed, 0.5 half speed, etc.
  
   With unit "c", speed specifies the playback rate relative to cycle
   length. So unit "c" # speed "1" will speed up or slow down the sample
   to fit in one cycle, unit "c" # speed "2" will play the sample twice
   as fast (so that it fits in half a cycle), etc. This can be useful for
   beat matching if your sample is a drum loop.
  
   With unit "s", speed specifies the playback length in seconds.
  
   formant filter to make things sound like vowels, a pattern of either
   a, e, i, o or u. Use a rest (~) for no effect.

** Composition of Patterns
  
   Most often, parameters are composed together into synth messages using
   the # operator. Using #, if you specify the same parameter more than
   once, you will replace previous values. For example, in the following
   the rightmost speed value of 2 is what gets used, and the value of 3
   is ignored:
  
   d1 $ sound "bd sn:2" # speed "3" # speed "2"
  
   Actually, # is shorthand for the |=| operator, and there are a few
   others which behave a bit differently. For example instead of
   replacing values, the |+| operator adds them together. For example the
   following ends up with a value of 5.
  
   d1 $ sound "bd sn:2" # speed "3" |+| speed "2"
  
   There also exists |*|, |/| and |-| operators which multiply, divide
   and subtract the values, as you might expect. Here’s a pattern which
   adds values taken from a sine fucntion to a speed pattern:
  
   d1 $ every 2 (|+| speed sine1) $ sound "bd*2" # speed "1 2"

   The |+| |-| |/| and |*| operators only exhibit this behaviour with
   numerical pattern parameters.  specific to Tidal
  
   The general rule for things that combine patterns is that they use the
   structure of the pattern on the left.
   | + | , | * | , | - | , | / |

   Operate on ParamPatterns, and perform the arithmetic operation if the
   two parameters are the same (such as speed and speed), or simply merge
   the parameters just as # would if the parameters are different.
  
   speed "1 2 3 4" |+| speed "2"
  
   is the same as #, |=|
  
   They mean the same thing: they merge ParamPatterns together ###, ***, +++, ///
  
   These take a list of ParamPatterns as their second argument, and merge
   them all together with the relevant arithmetic operator. Can simplify
   long expressions.
  
   d1 $ s "bd sn" # speed "1.2" *** [speed "2", crush "4"]
  
   <~, ~>
  
   These time-shift the pattern on the RHS by the number of cycles on the
   LHS.
  
   is the same as <~>
  
   Pattern replacement: takes the elements of the second pattern and
   makes a new pattern using the structure of the first
  
   is the same as
  
   one cycle and
  
   the next cycle <<~, ~>>
  
   Pattern rotation, these move the elements of the pattern without
   changing the structure of the pattern
  
   is the same as !!!
  
   List indexing with built-in modulo so you can’t go past the end of the
   list
  
   returns 2 useful Haskell operators <$>
  
   A synonym for fmap, useful for mapping numerical functions so they
   work on patterns.  <*>
  
   A synonym for ap, useful for promoting functions to work with
   patterns.
  
   is the same as "3 4 5 6"
  
   (+) <$> "1 2 3 4" <*> "2"
  
   is also the same !!
  
   Haskell’s way of doing list indexing $
  
   An alternative to parentheses, means “evaluate everything on the right
   first” .
  
   Function composition, needs functions with only a single argument
   unspecified
  
   choose randomly picks an element from the given list:
  
   d1 $ s "arpy*4" # n (choose [0,2,5])
  
   d1 $ sometimes (|+| up (choose[3, 7, 2, 9, (-3), (-7), (-9), (-2)])) $ n "~ 0 ~ 0" # s "sid"
  
   irand n generates a pattern of (pseudo-)random integers between 0 to
   n-1 inclusive. Notably used to pick a random samples from a folder:
  
   d1 $ sound "amencutup*8" # n (irand 8)
  
** pequal :: Ord a => Time -> Pattern a -> Pattern a -> Bool
  
   Quickly test if the first and the second given pattern are the same in
   the given number of cycles. This is more of a building block for
   higher-level tidal functions.

** rand
   rand generates a pattern of (pseudo-)random, floating point numbers
   between 0 and 1. For example, to bound randomly around the stereo
   field you can do this:
  
   d1 $ sound "bd*8" # pan rand
  
   Or to enjoy randomised speed from 0.5 to 1.5, you can simply add 0.5
   to it:
  
   d1 $ sound "arpy*4" # speed (rand + 0.5)
  
** run
   run n generates a pattern representing a cycle of numbers from 0 to
   n-1 inclusive. Notably used to ‘run’ through a folder of samples in
   order:
  
   d1 $ n (run 8) # sound "amencutup"
  
   d1 $ every 2 (slow 2) $ n (run 8) # sound "amencutup"
  
   The first parameter to run can be given as a pattern:
  
   d1 $ n (run "<4 8 4 6>") # sound "amencutup"
  
** scale
   scale will take a pattern which goes from 0 to 1 (like sine), and
   scale it to a different range - between the first and second
   arguments. In the below example, scale 1 1.5 shifts the range of sine
   from 0 - 1 to 1 - 1.5.
  
   d1 $ jux (iter 4) $ sound "arpy arpy:2*2" |+| speed (slow 4 $ scale 1 1.5 sine) |

   The above is the equivalent of the following:

   d1 $ jux (iter 4) $ sound "arpy arpy:2*2" |+| speed (slow 4 $ sine * 0.5 + 1) |

** scalex
   scalex is an exponential version of scale, good to use for
   frequencies. For example, scale 20 2000 "0.5" will give 1010 - halfway
   between 20 and 2000. But scalex 20 2000 0.5 will give 200 - halfway
   between on a logarithmic scale. This usually sounds better if you’re
   using the numbers as pitch frequencies. Since scalex uses logarithms,
   don’t try to scale things to zero or less!
  
** up
   up changes the speed of playback, but conforming to a 12-tone
   scale. The example below creates a pattern that plays the sample at 5
   semitones, then 3 semitones, above natural pitch.

   d1 $ up "5 3" # sound "arpy"

