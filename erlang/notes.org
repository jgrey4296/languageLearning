* Erlang Notes
** Shell: erl
   The shell is a shell of shells.
   Has tab completion
   q : quits
   ^G -> h : brings up shell control.
   f() or f(Variable) : clears bindings.
** Compiler: erlc
    #+begin_src erlang
      %%-compile([debug_info])
      %% {outdir, Dir}
      %% export_all
      %% {d,Macro}
      %% {d,Macro,Value}
   #+end_src
** Syntax
   expressions terminate with '. '  Note the whitespace
   Comments are %%

   Integers can be in the form: base#value. eg: 2#1010101.
   Variables start with an Uppercase letter or underscore.
   Atoms start lowercase, and are their own value.
   (Atoms are not garbage collected, don't generate them dynamically).
   'true' and 'false' are atoms.
   *Pattern matching is important*.

*** Comparisons
    Comparison ordering:
    number < atom < reference < fun < port < pid < tuple < list < bit string
    #+begin_src erlang
    %% Comparisons work across types.
    %% <, >, >=, =<.
    1 < 2. 
    #+end_src

    #+begin_src erlang
    %% and, or, xor, not.
    true and true.
    #+end_src

    #+begin_src erlang
    %% Exact (in)equality:
    1 =:= 1.
    1 =/= 2.
    %% Type eliding (in)equality:
    1 == 1.0.
    1 /= 2.0.
    #+end_src

*** Tuples
    #+begin_src erlang
      X = 10, Y = 4.
      Point = {X,Y}.
      %% pattern matching
      {A,B} = Point.
      {J,_} = Point.
    #+end_src
*** Lists
    #+begin_src erlang
      %% Not single typed. Lisp-like.
      %% Can be improper (last element a value) 
      %% and Proper (last element an empty list).
      [1,2,3,{4,5,6}].
      %% Strings are lists:
      [97,98,99] = "abc".

      %% Concat (right associative):
      [1,2,3] ++ [4,5].
      %% Remove (right associative):
      [1,2,3,4,5] -- [1,2,3].

      1 = hd([1,2,3,4]).
      tl([1,2,3,4]) = [2,3,4].
      %% or: [hd|tl].

    #+end_src

**** List Comprehensions
     [2*N || N <- [1,2,3,4]].
     [2*N || [_,N] <- [[1,2],[3,4]]].
     [X || X <- [1,2,3,4,5,6,7], X rem 2 =:= 0].
     [X+Y || X <- [1,2], Y <- [3,4]].
     [X || {X, fog} <- [{london, fog}, {newYork, sun}, {brisbane, fog}]]

*** Binary Data
    #+begin_src erlang
      ;; Between << and >>, separated by commas.
      Color = 16#F09A29.
      Pixel = <<Color:24>>.

      <<Pix1:24, Pix2:24>> = Pixels.
      <<R:8, Rest/binary>> = Pixels.

      %% Value,
      %% Value:Size,
      %% Value/TypeSpecifierList
      %% Value:Size/TypeSpecifierList

      %% TypeSpecifierList delimiter: '-'
      %% Where Types can be: 
      %% integer, float, binary, bytes, bitstring, bits,
      %% utf8, utf16, utf32. 
      %% (signed and unsigned, big, little, and native, and unit).

      %% bsl, bsr : bt shifting.
      %% band, bor, bxor, bnot.

    #+end_src

*** Binary Strings
    #+begin_src erlang
          <<"this is a binary string">>.
    #+end_src

*** Binary Comprehensions
    #+begin_src erlang
      << <<X>> || <<X>> <= <<1,2,3,4,5>>, X rem 2 == 0>>.

    #+end_src

** Modules
   #+begin_src erlang
     %%To define attributes:
     -module(Name).
     -export([Function1/Arity, Function2/Arity...])
     -import(Module, [Function/Arity..])
     ;;to call:
      Module:Function(arguments).
   #+end_src

   Inspect metadata with the function module_info().

** Functions
   #+begin_src erlang
     testFunc() ->
         io:format("hello").
   #+end_src

*** Pattern Matching
    Function clauses combine to make a declaration.
    *Note the intermediate semicolons and  final full stop*
    use for Head and tail of list: [H|T].
    "Don't Care" variable: _
    #+begin_src erlang
      greet(male, Name) ->
          io:format("Hello, Mr ~s", [Name]);
      greet(female, Name) ->
          io:format("Hello, Mrs ~s", [Name]);
      greet(_, Name) ->
          io:format("Hello, ~s", [Name]).
    #+end_src

    
    #+begin_src erlang
      same(X,X) ->
          true;
      same(_,_) ->
          false.
    #+end_src
    
    use of "=" in head:
    #+begin_src erlang
      valid_time({Date = {Y,M,D}, Time = {H,Min,S}}) ->
          io:format("correct");
      valid_time(_) ->
          io:format("Bad Data").
    #+end_src

    
*** Guards:
    Comma for 'and', Semicolon for 'or'
    Can use math, comparison and type check functions,
    Can't use user defined functions
    #+begin_src erlang
      a_test(X) when X >= 16 ->
          true;
      a_test(_) -> false.
    #+end_src

*** If
    Acts like guards. Must have a suitable clause
    #+begin_src erlang 
      if X > Y -> 2;
         X < Y -> 3;
         X == Y -> 4. %% must have a final clause
      end
    #+end_src
    
*** case .. of
    You can destructure cases. 
    #+begin_src erlang
      test(X,Set) ->
          case lists:member(X,Set) of
              true -> "In Set";
              false -> "Not in Set"
      end.             
    #+end_src
*** Printing
    io:format()
    Uses tildes  ("~s" for string, "~n" for newline)
    

** Macros
   #+begin_src erlang
   ;; A Macro:
   -define(MACRO, some_value).
   ?MACRO.
   ;;Macro Function:
   -define(sub(X,Y), X-Y).
   ;;Predefined:
   ?MODULE. ?FILE. ?LINE.
   ;;Conditional macros:
   -ifdef(DEBUG).
   -define(DEBUG(S), io:format("dbg: "++S)).
   else.
   -define(DEBUG(S), ok).
   -endif.
   #+end_src




