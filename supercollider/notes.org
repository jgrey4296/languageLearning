* Supercollider notes
** emacs specific:
C-c C-o         sclang-start
C-c C-c         sclang-eval-region-or-line
C-c C-s         stop sounds
C-c C-y         open sc help

C-c :           find definition
C-c ;           find references

** Useful Debugging / Introspection
   "test".dump // dumps information about the class/type, 
   "test".class // get the class type
   "test".inspect // opens up a detailed inspector
   "test".class.dumpInterface //prints all methods the class can respond to
   {...synthdef...}.scope //create a gui scope of the signal
   Server.instVarNames.dump //all instance variable names of a class
   "test".class.findMethod("blah")
   SynthDef... .dumpUGens
   this.dump // get info on the interpreter
   currentEnvironment.clear

*** Server Commands
    s.status
    s.boot
    s.reboot
    s.freeAll
    s.scope

** sclang
   
*** SynthDefs versus Synths
    The point is to abstract concepts from the server to the client.
    Class - Instance : SynthDef - Synth
    
    Synthdefs are eval'd *only once*, so changes are through messages,
    initializations, or ugens.
    
    { SinOsc.ar(440, 0, 0.2) }.play //a Sound Function:
    
    aSynthDef = SynthDef.new("tutorial", { Out.ar(0, Sin.ar(440, 0, 0.2)) }); //definition
    aSynth = aSynthDef.play //start it
    aSynth.free //stop it
    anotherSynth = Synth.new("tutorial") //creation by name

    //Must *add* the synth to the server:
    SynthDef.new("Blah",{arg pitch = 440; var outArray;
	    outArray = [SinOsc.ar(pitch,0,0.2), SinOsc.ar(pitch+2,0,0.2)];
    	Out.ar(0,outArray);
    }).add

    //then play it: *args can be symbols* eg: \pitch
    b = Synth.new("Blah", [ "pitch", 220 ])
    //combine with busses/groups:
    c = Synth.after(b,"Blah",["pitch",220]); 
    //Synth.head/tail/before/after/replace
    b.set("pitch",220) //modification
    //then kill it
    b.free
    
    //can move nodes with:
    //.moveBefore, .moveAfter, .moveToHead, .moveToTail

    //for feedback, use InFeedback.ar
    
*** UGens
//Oscillators:
SinOsc.ar/kr (freq, phase, amp, add)
PinkNoise.ar/kr (mul,add)
Saw.ar/kr (freq,mul,add)
Formant.ar (fundfreq,formfreq,bwfreq,mul,add)
LFSaw.ar/kr (freq,iphase,mul,add)
VarSaw.ar/kr (freq,iphase,width,mul,add)
LFPulse.ar/kr (freq,iphase,width,mul,add)
Impulse.ar/kr (freq,phase,mul,add)
SyncSaw.ar/kr (syncFreq,sawFreq,mul,add) // careful

//buffer playback:
PlayBuf.ar(numChannels, buffer, rateOfPlayback) //rate: -n <-> n
BufRateScale.kr(buffer)
RecordBuf.ar(source,buffer)
DiskIn.ar //Streaming

//Effects:
Pan2.ar/kr (in, pos,level)
Mix.ar (array)
Decay2.ar/kr (in, attackTime, decayTime, mul, add)
AllpassC.ar/kr (in, maxDelaytime, delaytime, decaytime, mul, add)

//Envelopes
EnvGen.ar/kr (envelope, gate, levelScale, levelBias, timeScale, doneAction)
Env.perc/triangle/sine/linen/xyc/pairs/step/cutoff/dadsr/adsr/asr/circle

Out.ar/kr (busNum, numChannels)
In.ar/kr  (busNum, numChannels)
InFeedback.ar

Rand(low,high)
White/Brow/PinkNoise
Crackle
LFNoise0/1/2
Dust/Dust2

*** Busses
    //For Routing audio
    b = Bus.control(server, numChannels=1)
    b = Bus.audio(server, numChannels=1)

    b = Bus.audio(s)
    b.index 
    b.numChannels
    b.free

    //can map any synth arg to read from a control bus
    x.map(\freq1,b,\freq2, c)

    //can also set/get constant values to a bus
    b.get({ |val| val.postln; });
    b.set(30)
    // set the synth to a constant value, unmapping from control
    x.set(\freq2, 100)

*** Groups
    g = Group.new;
    h = Group.before(g);
    g.free; h.free;
    
    //creating a new synth in a group
    Synth(\tutorial..,[\inBus,b],g)
   
    g.set(\amp,0.005) // sends set message to all nodes inside group

*** Buffers
    b = Buffer.alloc(server,frames,channels)

    b = Buffer.alloc(s,s.sampleRate * 8.0, 2) //8 seconds
    b = Buffer.read(s, "/path/to/file.wav")

    //Play the buffer:
    ({Out.ar(0,PlayBuf.ar(1,b,BufRateScale.kr(b)))}).play;
    
    //for streaming:
    b = Buffer.cueSoundFile(s,filePath, 0, 1)

    //Buffers can get and set data, but interleave frames for multichannel.
    //so i: 0=f1-chan1, 1=f1-chan2, 2=f2-chan1...
    //get is asynch

*** Classes
    *method = class method
    'this' refers to instance
    *NEEDS TO BE IN ~/github/.super_collider_classes*
    *or Platform.userExtensionDir*

    MyClass {
    	var <a,>b,<>c; //get,set,both
        classvar blah;

		*new { ^super.new }
    }



*** Syntax Shortcuts
**** Multiple assignment
#a,b,c = [1,2,3]
#[a,b,c] = [1,2,3]

**** Series assignment
a = (start,next..end)

**** Geometry
2 @ 3 : Point(2,3)
point @ point : rectangle, top left -> bottom right

rect & rect : intersection of rectangles
rect | rect : union of rectangles

*** list comprehension
    //defined as routines:
    {: x, x <- (1..5) }
    {: [x,y], x <- 2, y <- (1..5), (x+y).isprime }
    
    //use 'all' to get the values out:
    all {:x, x <- (1..5)

    //generator clauses: v <- e
    //var clauses: var v = e
    //expression clauses: :: e
    //termination clause: :while e

*** Variables
    defined with 'var' after the open curly bracket
    of a function.
    
    ~varName -> create an environment variable
    //Environments allow for stack control of variables?
    (Environment.new.push; currentEnvironment.pop;)
    
*** Functions
    a = { arg a; a + 2 }
    a = {|a| a + 2}
    a.value(2) //4
    //Functions return the last value eval'd.
    //Methods return with ^

*** Operators
== : Equivalance
=== : identity
& : bitwise and
bitwise or: |
<< : bitwise left
>> : bitwise right
&& : logical and
logical or: ||

++ : concatenation
+++ : lamination (repeating combination/pairing)

@ : array indexing (.at)
@@ : array index with wrapping (.wrapAt)
@|@ : array index with folding (.foldAt)
|@| : array index with clipping (.clipAt)

<> : function composition (going RIGHT to LEFT)

*** GUI
    w = Window.new("GUI Introduction", Rect(200,200,255,100));
    b = Button.new(w,Rect(10,0,80,30)).states_([["Hide"],["Show"]]);
    s = Slider.new(w,Rect(95,0,150,30));
    c = CompositeView.new(w,Rect(20,35,100,60));
    StaticText.new(c,Rect(0,0,80,30)).string_("Hello");
    StaticText.new(c,Rect(20,30,80,30)).string_("World!");
    b.action = { c.visible = b.value.asBoolean.not };
    s.action = { c.bounds = Rect( s.value * 150 + 20, 35, 100, 100 ) };
    w.front;

*** Control Flow
    if ( x, { then }, { else })
    while (testFunc, bodyFunc);
    while { (a=something) } { use a... }
    for (startVal, endVal, func);
    forBy(start, end, step, func);
    do(collection, function)

    switch(val, testVal1, trueFunc1,
			testValN, trueFuncN,
			defaultFunc);

*** Timing
**** Clocks
     //Tempo/System/App -Clock
     //System/App are in seconds
     
     SystemClock.sched(5,{"hello".postln;}); 
     
     var timeNow = TempoClock.default.beats;
     TempoClock.default.tempo = 2; // 2 beats / sec
     TempoClock.default.schedAbs(timeNow+5, {..});
     
     thisThread.clock.beats;
     
     //returning a number shedules a repeat:
     SystemClock.sched(5,{"hello".postln; 2})

**** Scheduling
     //Routines and yield

     r = Routine({
     "a".yield;
     "b".yield;
     "c".yield;
     });
     
     //return numbers for clock based rescheduling:
     r = Routine({
	 loop {
		 "something".postln;
    	 rrand(1,3).yield;
     	}
      });
 
      //creating scheduled sound:
      r = Routine({
	  loop{
	  var pitch = rrand(400,800),
	  wait = rrand(0.5,2);
	  ({SinOsc.ar(pitch,0,0.2) * EnvGen.kr(Env.perc(0.01,0.4), doneAction: 2)}).play;
	  wait.yield;
	  }
      });

      TempoClock.default.sched(0,r)
      //or:
      r.play
      r.stop

**** Tasks
     //A more controllable routine, pausable
     //can use ".wait" in place of ".yield"
     
     t = Task({
	 var i = 0, n = [440,560,880];
	 loop {
	 //note the folding at operator:
	 ({ SinOsc.ar(n@|@i,0,0.2) * EnvGen.kr(Env.perc(0.01,0.2), doneAction: 2);}).play;
	 i = i + 1;
	 0.5.wait;
	 }
     });

**** Synchronized timing:
     aRoutine.play(clock,quant)
     aRoutine.play(argClock, doReset, quant)
     
     //Specify a clock, whether to reset to start, 
     //and exact start time. 
     
     quant = [bar length,phase]
     //where u and v are tasks
     u.play(c,true,2);
     v.play(c,true,[2,0.5]);
     
     
     //When dealing with latency, wrap messages 
     //to the server with 'makeBundle':
     s.makeBundle(s.latency, {...});

*** Patterns
    a = Pseq([1,2,3,4,5], 1).asStream
    while { (m=a.next).notNil } {m.postln };



    //Patterns can be concatenated with ++
    //and composed with <>
    //played,
    //collected, selected, rejected

    Pseq (list, repeats, offset)
    Pshuf (list, repeats)
    Prand (list, repeats)
    //Exclusive random:
    Pxrand (list, repeats)
    //weighted random:
    Pwrand (list, weights, repeats)
    //-----
    Pseries (start, step, length)
    Pgeom (start, grow, length)
    Pwhite (lo, hi, length)
    Pexprand (lo, hi, length)


    //---- Filter Patterns
    //repeat a pattern as many times as necessary:
    Pn(pattern, repeats)
    //repeat ind values n times:
    Pstutter (n, pattern)
    
    //can use patterns inside of other patterns:
    p = Pwhite(0.0, Pseries(0.01,0.01,inf), 100)
    
**** Pbind
     //Pbind combines elements from patterns
     //into *key-value* events to pass to a synth


     //Create an instrument \smooth
     //and trigger repeatedly
     p = Pbind(
     	\instrument, \smooth,
        \midinote, Pseq([60, 72, 71], 1),
        \dur, Pseq([2, 2, 1], 1)
     ).play;


*** Events
    //Key-value pairs:
    e = (note:26, amp:0.1)
    //have prototypes for performance:
    e.play
    //can also specify synth with \instrument

*** Rests
    (
    // first, pitches ascending by 1-3 semitones, until 2 octaves are reached
    var    pitches = Pseries(0, Pconst(24, Pwhite(1, 3, inf)), inf).asStream.all,
    // randomly block 1/3 of those
    mask = pitches.scramble[0 .. pitches.size div: 3];

    p = Pbind(
    \arpeg, Pseq(pitches[ .. pitches.size - 2] ++ pitches.reverse[ .. pitches.size - 2], inf),
    // if the note is found in the mask array, replace it with Rest
    // then that note does not sound
    \note, Pif(Pfunc { |event| mask.includes(event[\arpeg]) }, Rest, Pkey(\arpeg)),
    \octave, 4,
    \dur, 0.125
    ).play;
    )



*** Data Structures
    Array // Fixed Size
    List // Variable Size. Uses 'add','pop','addFirst', insert,removeAt
    Dictionary //uses [ ] access, can take strings, symbols, objects...
**** Sets
Set.new
set.add
set & set : intersection
set | set : union
set - set : difference
set -- set : symmetric different


*** Useful Examples
8.rand //generate random number from 0-8
#[1,2,3] //literal, constant array
Ref.new(a) //create a reference to a
[1,2,3,4].choose // random num from array
10.do({|x| "hello".postln}) //no returns
x ! n // create array of x, n times

** scsynth
   
